% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{lag_it}
\alias{lag_it}
\title{Apply a lag to the rows of a \emph{time series} or a \emph{matrix} using
\code{RcppArmadillo}.}
\usage{
lag_it(tseries, lagg = 1L, pad_zeros = TRUE)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix}.}

\item{\code{lagg}}{An \emph{integer} equal to the number of periods to lag
(the default is \code{lagg = 1}).}

\item{\code{pad_zeros}}{\emph{Boolean} argument: Should the output be padded
with zeros? (The default is \code{pad_zeros = TRUE}.)}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{tseries}.
}
\description{
Apply a lag to the rows of a \emph{time series} or a \emph{matrix} using
\code{RcppArmadillo}.
}
\details{
The function \code{lag_it()} applies a lag to the input \emph{matrix} by
  shifting its rows by the number equal to the argument \code{lagg}. For
  positive \code{lagg} values, the rows are shifted \emph{forward} (down),
  and for negative \code{lagg} values they are shifted \emph{backward} (up).
  
  The output \emph{matrix} is padded with either zeros (the default), or
  with rows of data from \code{tseries}, so that it has the same dimensions
  as \code{tseries}.
  If the \code{lagg} is positive, then the first row is copied and added
  upfront.
  If the \code{lagg} is negative, then the last row is copied and added
  to the end.
  
  As a rule, if \code{tseries} contains returns data, then the output
  \emph{matrix} should be padded with zeros, to avoid data snooping.
  If \code{tseries} contains prices, then the output \emph{matrix} should
  be padded with the prices.
}
\examples{
\dontrun{
# Create a matrix of random returns
re_turns <- matrix(rnorm(5e6), nc=5)
# Compare lag_it() with rutils::lag_it()
all.equal(HighFreq::lag_it(re_turns), 
  rutils::lag_it(re_turns))
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::lag_it(re_turns),
  Rcode=rutils::lag_it(re_turns),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
