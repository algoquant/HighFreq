% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{sim_df}
\alias{sim_df}
\title{Simulate a \emph{Dickey-Fuller} process using \emph{Rcpp}.}
\usage{
sim_df(eq_price, volat, theta, coeff, innov)
}
\arguments{
\item{\code{volat}}{The volatility of returns.}

\item{\code{eq_price}}{The equilibrium price.}

\item{\code{theta}}{The strength of mean reversion.}

\item{\code{coeff}}{A single-column \emph{matrix} of \emph{autoregressive}
coefficients.}

\item{\code{innov}}{A single-column \emph{matrix} of innovations (random
numbers).}
}
\value{
A single-column \emph{matrix} of simulated returns, with the same
  number of rows as the argument \code{innov}.
}
\description{
Simulate a \emph{Dickey-Fuller} process using \emph{Rcpp}.
}
\details{
The function \code{sim_df()} simulates the following \emph{Dickey-Fuller}
  process:
  \deqn{
    r_i = \theta \, (\mu - p_{i-1}) + \varphi_1 r_{i-1} + \ldots + \varphi_p r_{i-p} + \sigma \, \xi_i
  }
  \deqn{
    p_i = p_{i-1} + r_i
  }
  Where \eqn{r_i} and \eqn{p_i} are the simulated returns and prices,
  \eqn{\theta}, \eqn{\mu}, and \eqn{\sigma} are the
  \emph{Ornstein-Uhlenbeck} parameters, \eqn{\varphi_i} are the
  \emph{autoregressive} coefficients, and \eqn{\xi_i} are the standard
  normal \emph{innovations}.
  The recursion starts with: \eqn{p_1 = r_1 = \sigma \, \xi_1}.

  The \emph{Dickey-Fuller} process is a combination of an
  \emph{Ornstein-Uhlenbeck} process and an \emph{autoregressive} process.
  The order \eqn{p} of the \emph{autoregressive} process \eqn{AR(p)}, is
  equal to the number of rows of the \emph{autoregressive} coefficients
  \code{coeff}.

  The function \code{sim_df()} simulates the \emph{Dickey-Fuller}
  process using fast \emph{Rcpp} \code{C++} code.

  The function \code{sim_df()} returns a single-column \emph{matrix}
  representing the \emph{time series} of returns.
}
\examples{
\dontrun{
# Define the Ornstein-Uhlenbeck model parameters
eq_price <- 1.0
sig_ma <- 0.01
the_ta <- 0.01
# Define AR coefficients
co_eff <- matrix(c(0.2, 0.2))
# Calculate matrix of innovations
in_nov <- matrix(rnorm(1e3))
# Simulate Dickey-Fuller process using Rcpp
re_turns <- HighFreq::sim_df(eq_price=eq_price, volat=sig_ma, 
  theta=the_ta, co_eff, innov=in_nov)
plot(cumsum(re_turns), t="l", main="Simulated Dickey-Fuller Prices")
}

}
