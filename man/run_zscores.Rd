% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_zscores}
\alias{run_zscores}
\title{Calculate the trailing means, volatilities, and z-scores of a streaming
\emph{time series} of data using an online recursive formula.}
\usage{
run_zscores(tseries, lambda)
}
\arguments{
\item{\code{tseries}}{A single \emph{time series} or a single column
\emph{matrix} of data.}

\item{\code{lambda}}{A decay factor which multiplies past estimates.}
}
\value{
A \emph{matrix} with three columns (means, volatilities, and
  z-scores) and the same number of rows as the input argument
  \code{tseries}.
}
\description{
Calculate the trailing means, volatilities, and z-scores of a streaming
\emph{time series} of data using an online recursive formula.
}
\details{
The function \code{run_zscores()} calculates the trailing means,
  volatilities, and z-scores of a single streaming \emph{time series} of
  data \eqn{r_t}, by recursively weighting the past variance estimates
  \eqn{\sigma^2_{t-1}}, with the squared differences of the data minus its
  trailing means \eqn{(r_t - \bar{r}_t)^2}, using the decay factor
  \eqn{\lambda}:
  \deqn{
    \bar{r}_t = \lambda \bar{r}_{t-1} + (1-\lambda) r_t
  }
  \deqn{
    \sigma^2_t = \lambda \sigma^2_{t-1} + (1-\lambda) (r_t - \bar{r}_t)^2
  }
  \deqn{
    z_t = \frac{r_t - \bar{r}_t}{\sigma_t}
  }
  Where \eqn{r_t} are the streaming data, \eqn{\bar{r}_t} are the trailing
  means, \eqn{\sigma^2_t} are the trailing variance estimates, and \eqn{z_t}
  are the z-scores.
  
  The above online recursive formulas are convenient for processing live
  streaming data because they don't require maintaining a buffer of past
  data.
  The formulas are equivalent to a convolution with exponentially decaying
  weights, but they're much faster to calculate.
  Using exponentially decaying weights is more natural than using a sliding
  look-back interval, because it gradually "forgets" about the past data.

  The value of the decay factor \eqn{\lambda} must be in the range between
  \code{0} and \code{1}.  
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, and the trailing variance values have a
  stronger dependence on past data.  This is equivalent to a long
  look-back interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, and the trailing variance values have a
  weaker dependence on past data.  This is equivalent to a short look-back
  interval.

  The function \code{run_zscores()} returns a \emph{matrix} with three
  columns (means, volatilities, and z-scores) and the same number of rows as
  the input argument \code{tseries}.
}
\examples{
\dontrun{
# Calculate historical VTI log prices
pricev <- log(na.omit(rutils::etfenv$prices$VTI))
# Calculate the trailing variance and z-scores of prices
lambdaf <- 0.9 # Decay factor
zscores <- HighFreq::run_zscores(pricev, lambda=lambdaf)
datav <- cbind(pricev, zscores[, 3])
colnames(datav) <- c("VTI", "Zscores")
colnamev <- colnames(datav)
dygraphs::dygraph(datav, main="VTI Prices and Z-scores") \%>\%
   dyAxis("y", label=colnamev[1], independentTicks=TRUE) \%>\%
   dyAxis("y2", label=colnamev[2], independentTicks=TRUE) \%>\%
   dySeries(axis="y", label=colnamev[1], strokeWidth=2, col="blue") \%>\%
   dySeries(axis="y2", label=colnamev[2], strokeWidth=2, col="red") \%>\%
   dyLegend(show="always", width=300)
}

}
