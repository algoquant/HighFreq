% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{sim_portfoptim}
\alias{sim_portfoptim}
\title{Simulate a portfolio optimization strategy using online (recursive) updating
of the covariance matrix.}
\usage{
sim_portfoptim(rets, dimax, lambda, lambdacov, lambdaw)
}
\arguments{
\item{\code{rets}}{A \emph{time series} or \emph{matrix} of asset returns.}

\item{\code{dimax}}{An \emph{integer} equal to the number of \emph{eigen
values} used for calculating the reduced inverse of the covariance
matrix (the default is \code{dimax = 0} - standard matrix inverse using
all the \emph{eigen values}).}

\item{\code{lambda}}{A decay factor which multiplies the past asset returns.}

\item{\code{lambdacov}}{A decay factor which multiplies the past covariance.}

\item{\code{lambdaw}}{A decay factor which multiplies the past portfolio
weights.}
}
\value{
A \emph{matrix} of strategy returns and the portfolio weights, with
  the same number of rows as the argument \code{rets}.
}
\description{
Simulate a portfolio optimization strategy using online (recursive) updating
of the covariance matrix.
}
\details{
The function \code{sim_portfoptim()} simulates a portfolio optimization
  strategy. The strategy calculates the maximum Sharpe portfolio weights
  \emph{in-sample} at every point in time, and applies them in the
  \emph{out-of-sample} time interval.  It updates the trailing covariance
  matrix recursively, instead of using past batches of data. The function
  \code{sim_portfoptim()} uses three different decay factors for averaging past
  values, to reduce the variance of its forecasts.
  
  The function \code{sim_portfoptim()} first scales the returns by their
  trailing volatilities:
  \deqn{
    r^s_t = \frac{r_t}{\sigma_{t-1}}
  }
  Returns scaled by their volatility are more stationary so they're easier
  to model.
  
  Then at every point in time, the function \code{sim_portfoptim()} calls
  the function \code{HighFreq::push_covar()} to update the trailing
  covariance matrix of the returns:
  \deqn{
    \bar{r}_t = \lambda_c \bar{r}_{t-1} + (1-\lambda_c) r^s_t
  }
  \deqn{
    \hat{r}_t = r^s_t - \bar{r}_t
  }
  \deqn{
    {cov}_t = \lambda_c {cov}_{t-1} + (1-\lambda_c) \hat{r}^T_t \hat{r}_t
  }
  Where \eqn{\lambda_c} is the decay factor which multiplies the past mean
  and covariance.
  
  It then calls the function \code{HighFreq::calc_inv()} to calculate the
  \emph{reduced inverse} of the covariance matrix using its eigen
  decomposition:
  \deqn{
    \strong{C}^{-1} = \strong{O}_{dimax} \, \Sigma^{-1}_{dimax} \, \strong{O}^T_{dimax}
  }
  See the function \code{HighFreq::calc_inv()} for details.
  
  It then calculates the \emph{in-sample} weights of the maximum Sharpe
  portfolio, by multiplying the inverse covariance matrix times the trailing
  means of the asset returns:
  \deqn{
    \bar{r}_t = \lambda \bar{r}_{t-1} + (1-\lambda) r^s_t
  }
  \deqn{
    \strong{w}_t = \strong{C}^{-1} \bar{r}_t
  }
  Note that the decay factor \eqn{\lambda} is different from the decay
  factor \eqn{\lambda_c} used for updating the trailing covariance
  matrix.
  
  It then scales the weights so their sum of squares is equal to one:
  \deqn{
    \strong{w}_t = \frac{\strong{w}_t}{\sqrt{\sum{\strong{w}^2_t}}}
  }
  
  It then calculates the trailing mean of the weights:
  \deqn{
    \bar{\strong{w}}_t = \lambda_w \bar{\strong{w}}_{t-1} + (1-\lambda_w) \strong{w}_t
  }
  Note that the decay factor \eqn{\lambda_w} is different from the decay
  factor \eqn{\lambda} used for updating the trailing means.
  
  It finally calculates the \emph{out-of-sample} portfolio returns by
  multiplying the trailing mean weights times the scaled asset returns:
  \deqn{
    r^p_t = \bar{\strong{w}}_{t-1} r^s_t
  }
  Applying weights to scaled returns means trading stock amounts with unit
  dollar volatility.  So if the weight is equal to \code{2} then we should
  purchase an amount of stock with dollar volatility equal to \code{2}
  dollars.  Trading stock amounts with unit dollar volatility improves
  portfolio diversification.
  
  The function \code{sim_portfoptim()} uses three different decay factors
  for averaging past values, to reduce the variance of its forecasts. The
  value of the decay factor \eqn{\lambda} must be in the range between
  \code{0} and \code{1}.
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, so the trailing values have a greater
  dependence on past data.  This is equivalent to a long look-back
  interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, so the trailing values have a weaker
  dependence on past data.  This is equivalent to a short look-back
  interval.

  The function \code{sim_portfoptim()} returns multiple columns of data,
  with the same number of rows as the input argument \code{rets}. The first
  column contains the strategy returns and the remaining columns contain the
  portfolio weights.
}
\examples{
\dontrun{
# Load ETF returns
retp <- rutils::etfenv$returns[, c("VTI", "TLT", "DBC", "USO", "XLF", "XLK")]
retp <- na.omit(retp)
datev <- zoo::index(retp) # dates
# Simulate a portfolio optimization strategy
dimax <- 6
lambda <- 0.978
lambdacov <- 0.995
lambdaw <- 0.9
pnls <- HighFreq::sim_portfoptim(retp, dimax, lambda, lambdacov, lambdaw)
colnames(pnls) <- c("pnls", "VTI", "TLT", "DBC", "USO", "XLF", "XLK")
pnls <- xts::xts(pnls, order.by=datev)
# Plot dygraph of strategy
wealthv <- cbind(retp$VTI, pnls$pnls*sd(retp$VTI)/sd(pnls$pnls))
colnames(wealthv) <- c("VTI", "Strategy")
endd <- rutils::calc_endpoints(wealthv, interval="weeks")
dygraphs::dygraph(cumsum(wealthv)[endd], main="Portfolio Optimization Strategy Returns") \%>\%
 dyOptions(colors=c("blue", "red"), strokeWidth=2) \%>\%
 dyLegend(width=300)
# Plot dygraph of weights
symbolv <- "VTI"
stockweights <- cbind(cumsum(get(symbolv, retp)), get(symbolv, pnls))
colnames(stockweights)[2] <- "Weight"
colnamev <- colnames(stockweights)
endd <- rutils::calc_endpoints(pnls, interval="weeks")
dygraphs::dygraph(stockweights[endd], main="Returns and Weight") \%>\%
  dyAxis("y", label=colnamev[1], independentTicks=TRUE) \%>\%
  dyAxis("y2", label=colnamev[2], independentTicks=TRUE) \%>\%
  dySeries(axis="y", label=colnamev[1], strokeWidth=2, col="blue") \%>\%
  dySeries(axis="y2", label=colnamev[2], strokeWidth=2, col="red")
}

}
