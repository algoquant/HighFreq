% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{mult_vec_mat}
\alias{mult_vec_mat}
\title{Multiply in place (without copying) the columns or rows of a \emph{matrix}
times a \emph{vector}, element-wise.}
\usage{
mult_vec_mat(vector, matrix, by_col = TRUE)
}
\arguments{
\item{\code{vector}}{A \emph{vector}.}

\item{\code{matrix}}{A \emph{matrix}.}

\item{\code{by_col}}{A \emph{Boolean} argument: if \code{TRUE} then multiply
the columns, otherwise multiply the rows. (The default is
\code{by_col = TRUE}.)}
}
\value{
A single \emph{integer} value, equal to either the number of
  \emph{matrix} columns or the number of rows.
}
\description{
Multiply in place (without copying) the columns or rows of a \emph{matrix}
times a \emph{vector}, element-wise.
}
\details{
The function \code{mult_vec_mat()} multiplies the columns or rows of a
  \emph{matrix} times a \emph{vector}, element-wise.

  If the number of \emph{vector} elements is equal to the number of matrix
  columns, then it multiplies the columns by the \emph{vector}, and returns
  the number of columns. If the number of \emph{vector} elements is equal to
  the number of rows, then it multiplies the rows, and returns the number of
  rows.

  If the \emph{matrix} is square and if \code{by_col} is \code{TRUE} then it
  multiplies the columns, otherwise it multiplies the rows.
  
  It accepts \emph{pointers} to the \emph{matrix} and \emph{vector}, and
  replaces the old \emph{matrix} values with the new values.
  It performs the calculation in place, without copying the \emph{matrix} in
  memory (which greatly increases the computation speed).
  It performs an implicit loop over the \emph{matrix} rows and columns using
  the \emph{Armadillo} operators \code{each_row()} and \code{each_col()},
  instead of performing explicit \code{for()} loops (both methods are
  equally fast).

  The function \code{mult_vec_mat()} uses \code{RcppArmadillo} \code{C++}
  code, so when multiplying large \emph{matrix} columns it's several times
  faster than vectorized \code{R} code, and it's even much faster compared
  to \code{R} when multiplying the \emph{matrix} rows.
}
\examples{
\dontrun{
# Multiply matrix columns using R
mat_rix <- matrix(round(runif(25e4), 2), nc=5e2)
vec_tor <- round(runif(5e2), 2)
prod_uct <- vec_tor*mat_rix
# Multiply the matrix in place
HighFreq::mult_vec_mat(vec_tor, mat_rix)
all.equal(prod_uct, mat_rix)
# Compare the speed of Rcpp with R code
library(microbenchmark)
summary(microbenchmark(
    Rcpp=HighFreq::mult_vec_mat(vec_tor, mat_rix),
    Rcode=vec_tor*mat_rix,
    times=10))[, c(1, 4, 5)]  # end microbenchmark summary

# Multiply matrix rows using R
mat_rix <- matrix(round(runif(25e4), 2), nc=5e2)
vec_tor <- round(runif(5e2), 2)
prod_uct <- t(vec_tor*t(mat_rix))
# Multiply the matrix in place
HighFreq::mult_vec_mat(vec_tor, mat_rix, by_col=FALSE)
all.equal(prod_uct, mat_rix)
# Compare the speed of Rcpp with R code
library(microbenchmark)
summary(microbenchmark(
    Rcpp=HighFreq::mult_vec_mat(vec_tor, mat_rix, by_col=FALSE),
    Rcode=t(vec_tor*t(mat_rix)),
    times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
