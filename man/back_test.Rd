% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{back_test}
\alias{back_test}
\title{Simulate (backtest) a rolling portfolio optimization strategy, using
\code{RcppArmadillo}.}
\usage{
back_test(
  excess,
  returns,
  startp,
  endp,
  lambda = 0,
  method = "sharpem",
  eigen_thresh = 1e-05,
  eigen_max = 0L,
  confl = 0.1,
  alpha = 0,
  rankw = FALSE,
  centerw = FALSE,
  scalew = "voltarget",
  vol_target = 0.01,
  coeff = 1,
  bid_offer = 0
)
}
\arguments{
\item{\code{returns}}{A \emph{time series} or a \emph{matrix} of asset
returns data.}

\item{\code{excess}}{A \emph{time series} or a \emph{matrix} of excess
returns data (the returns in excess of the risk-free rate).}

\item{\code{startp}}{An \emph{integer vector} of start points.}

\item{\code{endp}}{An \emph{integer vector} of end points.}

\item{\code{lambda}}{A \emph{numeric} decay factor to multiply the past
portfolio weights.  (The default is \code{lambda = 0} - no memory.)}

\item{\code{coeff}}{A \emph{numeric} multiplier of the weights.  (The
default is \code{1})}

\item{\code{bid_offer}}{A \emph{numeric} bid-offer spread (the default is
\code{0})}

\item{\code{method}}{A \emph{string} specifying the method for calculating
the weights (see Details) (the default is \code{method = "sharpem"})}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small singular values in order to regularize the inverse of the
\code{covariance matrix} (the default is \code{1e-5}).}

\item{\code{eigen_max}}{An \emph{integer} equal to the number of singular
values used for calculating the regularized inverse of the \code{returns}
matrix (the default is \code{0} - equivalent to \code{eigen_max} equal to
the number of columns of \code{returns}).}

\item{\code{confl}}{The confidence level for calculating the
quantiles of returns (the default is \code{confl = 0.75}).}

\item{\code{alpha}}{The shrinkage intensity between \code{0} and \code{1}.
(the default is \code{0}).}

\item{\code{rankw}}{A \emph{Boolean} specifying whether the weights should
be ranked (the default is \code{rankw = FALSE}).}

\item{\code{centerw}}{A \emph{Boolean} specifying whether the weights should
be centered (the default is \code{centerw = FALSE}).}

\item{\code{scalew}}{A \emph{string} specifying the method for scaling
the weights (the default is \code{scalew = "voltarget"}).}

\item{\code{vol_target}}{A \emph{numeric} volatility target for scaling the
weights (the default is \code{1e-5})}
}
\value{
A column \emph{vector} of strategy returns, with the same length as
  the number of rows of \code{returns}.
}
\description{
Simulate (backtest) a rolling portfolio optimization strategy, using
\code{RcppArmadillo}.
}
\details{
The function \code{back_test()} performs a backtest simulation of a
  rolling portfolio optimization strategy over a \emph{vector} of the end
  points \code{endp}.
  
  It performs a loop over the end points \code{endp}, and subsets the
  \emph{matrix} of the excess asset returns \code{excess} along its rows,
  between the corresponding \emph{start point} and the \emph{end point}. It
  passes the subset matrix of excess returns into the function
  \code{calc_weights()}, which calculates the optimal portfolio weights at
  each \emph{end point}. The arguments \code{eigen_max}, \code{alpha},
  \code{method}, \code{rankw}, \code{centerw}, and \code{scalew} are
  also passed to the function \code{calc_weights()}.
  
  It then recursively averages the weights \eqn{w_i} at the \emph{end point
  = i} with the weights \eqn{w_{i-1}} from the previous \emph{end point =
  (i-1)}, using the decay factor \code{lambda = \eqn{\lambda}}:
  \deqn{
    w_i = (1-\lambda) w_i + \lambda w_{i-1}
  }
  The purpose of averaging the weights is to reduce their variance, to
  improve their out-of-sample performance.  It is equivalent to extending
  the portfolio holding period beyond the time interval between neighboring
  \emph{end points}.
  
  The function \code{back_test()} then calculates the out-of-sample strategy
  returns by multiplying the average weights times the future asset returns.
  
  The function \code{back_test()} multiplies the out-of-sample strategy
  returns by the coefficient \code{coeff} (with default equal to \code{1}),
  which allows simulating either a trending strategy (if \code{coeff = 1}),
  or a reverting strategy (if \code{coeff = -1}).
  
  The function \code{back_test()} calculates the transaction costs by
  multiplying the bid-offer spread \code{bid_offer} times the absolute
  difference between the current weights minus the weights from the previous
  period. Then it subtracts the transaction costs from the out-of-sample
  strategy returns.
  
  The function \code{back_test()} returns a \emph{time series} (column
  \emph{vector}) of strategy returns, of the same length as the number of
  rows of \code{returns}.
}
\examples{
\dontrun{
# Calculate the ETF daily excess returns
returns <- na.omit(rutils::etfenv$returns[, 1:16])
# riskf is the daily risk-free rate
riskf <- 0.03/260
excess <- returns - riskf
# Define monthly end points without initial warmpup period
endp <- rutils::calc_endpoints(returns, interval="months")
endp <- endp[endp > 0]
nrows <- NROW(endp)
# Define 12-month look-back interval and start points over sliding window
look_back <- 12
startp <- c(rep_len(1, look_back-1), endp[1:(nrows-look_back+1)])
# Define return shrinkage and regularization intensities
alpha <- 0.5
eigen_max <- 3
# Simulate a monthly rolling portfolio optimization strategy
pnls <- HighFreq::back_test(excess, returns, 
                            startp-1, endp-1, 
                            eigen_max = eigen_max, 
                            alpha = alpha)
pnls <- xts::xts(pnls, index(returns))
colnames(pnls) <- "strat_rets"
# Plot dygraph of strategy
dygraphs::dygraph(cumsum(pnls), 
  main="Cumulative Returns of Max Sharpe Portfolio Strategy")
}

}
