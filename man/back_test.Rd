% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{back_test}
\alias{back_test}
\title{Simulate (backtest) a rolling portfolio optimization strategy, using
\code{RcppArmadillo}.}
\usage{
back_test(
  excess,
  returns,
  controlv,
  startp,
  endp,
  lambda = 0,
  coeff = 1,
  bid_offer = 0
)
}
\arguments{
\item{\code{returns}}{A \emph{time series} or a \emph{matrix} of asset
returns data.}

\item{\code{excess}}{A \emph{time series} or a \emph{matrix} of excess
returns data (the returns in excess of the risk-free rate).}

\item{\code{controlv}}{A \emph{list} of portfolio optimization model
parameters (see Details).}

\item{\code{startp}}{An \emph{integer vector} of start points.}

\item{\code{endp}}{An \emph{integer vector} of end points.}

\item{\code{lambda}}{A \emph{numeric} decay factor to multiply the past
portfolio weights.  (The default is \code{lambda = 0} - no memory.)}

\item{\code{coeff}}{A \emph{numeric} multiplier of the weights.  (The
default is \code{1})}

\item{\code{bid_offer}}{A \emph{numeric} bid-offer spread (the default is
\code{0})}
}
\value{
A column \emph{vector} of strategy returns, with the same length as
  the number of rows of \code{returns}.
}
\description{
Simulate (backtest) a rolling portfolio optimization strategy, using
\code{RcppArmadillo}.
}
\details{
The function \code{back_test()} performs a backtest simulation of a
  rolling portfolio optimization strategy over a \emph{vector} of the end
  points \code{endp}.
  
  It performs a loop over the end points \code{endp}, and subsets the
  \emph{matrix} of the excess asset returns \code{excess} along its rows,
  between the corresponding \emph{start point} and the \emph{end point}. 
  
  The function \code{back_test()} passes the subset matrix of excess returns
  into the function \code{calc_weights()}, which calculates the optimal
  portfolio weights at each \emph{end point}.
  It also passes to \code{calc_weights()} the argument \code{controlv},
  which is the list of portfolio optimization parameters.
  See the function \code{calc_weights()} for more details.
  The list of portfolio optimization parameters can be created using the
  function \code{param_portf()}.
  
  The function \code{back_test()} then recursively averages the weights
  \eqn{w_i} at the \emph{end point = i} with the weights \eqn{w_{i-1}} from
  the previous \emph{end point = (i-1)}, using the decay factor \code{lambda
  = \eqn{\lambda}}:
  \deqn{
    w_i = (1-\lambda) w_i + \lambda w_{i-1}
  }
  The purpose of averaging the weights is to reduce their variance, and
  improve their out-of-sample performance.  It is equivalent to extending
  the portfolio holding period beyond the time interval between neighboring
  \emph{end points}.
  
  The function \code{back_test()} then calculates the out-of-sample strategy
  returns by multiplying the average weights times the future asset returns.
  
  The function \code{back_test()} multiplies the out-of-sample strategy
  returns by the coefficient \code{coeff} (with default equal to \code{1}),
  which allows simulating either a trending strategy (if \code{coeff = 1}),
  or a reverting strategy (if \code{coeff = -1}).
  
  The function \code{back_test()} calculates the transaction costs by
  multiplying the bid-offer spread \code{bid_offer} times the absolute
  difference between the current weights minus the weights from the previous
  period. Then it subtracts the transaction costs from the out-of-sample
  strategy returns.
  
  The function \code{back_test()} returns a \emph{time series} (column
  \emph{vector}) of strategy returns, of the same length as the number of
  rows of \code{returns}.
}
\examples{
\dontrun{
# Calculate the ETF daily excess returns
returns <- na.omit(rutils::etfenv$returns[, 1:16])
# riskf is the daily risk-free rate
riskf <- 0.03/260
excess <- returns - riskf
# Define monthly end points without initial warmpup period
endp <- rutils::calc_endpoints(returns, interval="months")
endp <- endp[endp > 0]
nrows <- NROW(endp)
# Define 12-month look-back interval and start points over sliding window
look_back <- 12
startp <- c(rep_len(1, look_back-1), endp[1:(nrows-look_back+1)])
# Define return shrinkage and dimension reduction
alpha <- 0.5
dimax <- 3
# Create a list of portfolio optimization parameters
controlv <- HighFreq::param_portf(method="maxsharpe", dimax=dimax, alpha=alpha, scalew="sumsq")
# Simulate a monthly rolling portfolio optimization strategy
pnls <- HighFreq::back_test(excess, returns, controlv=controlv, startp=(startp-1), endp=(endp-1))
pnls <- xts::xts(pnls, index(returns))
colnames(pnls) <- "strat_rets"
# Plot dygraph of strategy
dygraphs::dygraph(cumsum(pnls), 
  main="Cumulative Returns of Max Sharpe Portfolio Strategy")
}

}
