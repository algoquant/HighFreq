% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{back_test}
\alias{back_test}
\title{Simulate (backtest) a rolling portfolio optimization strategy, using
\code{RcppArmadillo}.}
\usage{
back_test(
  excess,
  returns,
  startp,
  endp,
  method = "rank_sharpe",
  eigen_thresh = 0.001,
  eigen_max = 0L,
  con_fi = 0.1,
  alpha = 0,
  scale = TRUE,
  vol_target = 0.01,
  coeff = 1,
  bid_offer = 0
)
}
\arguments{
\item{\code{returns}}{A \emph{time series} or a \emph{matrix} of returns
data (the returns in excess of the risk-free rate).}

\item{\code{excess}}{A \emph{time series} or a \emph{matrix} of excess
returns data (the returns in excess of the risk-free rate).}

\item{\code{startp}}{An \emph{integer vector} of start points.}

\item{\code{endp}}{An \emph{integer vector} of end points.}

\item{\code{coeff}}{A \emph{numeric} multiplier of the weights.  (The
default is \code{1})}

\item{\code{bid_offer}}{A \emph{numeric} bid-offer spread (the default is
\code{0})}

\item{\code{method}}{A \emph{string} specifying the objective function for
calculating the weights (see Details) (the default is \code{method =
"rank_sharpe"})}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small singular values in order to regularize the inverse of the
\code{returns} matrix (the default is \code{0.001}).}

\item{\code{eigen_max}}{An \emph{integer} equal to the number of singular
values used for calculating the regularized inverse of the \code{returns}
matrix (the default is \code{0} - equivalent to \code{eigen_max} equal to
the number of columns of \code{returns}).}

\item{\code{con_fi}}{The confidence level for calculating the
quantiles (the default is \code{con_fi = 0.75}).}

\item{\code{alpha}}{The shrinkage intensity between \code{0} and \code{1}.
(the default is \code{0}).}

\item{\code{scale}}{A \emph{Boolean} specifying whether the weights should
be scaled (the default is \code{scale = TRUE}).}

\item{\code{vol_target}}{A \emph{numeric} volatility target for scaling the
weights (the default is \code{0.001})}
}
\value{
A column \emph{vector} of strategy returns, with the same length as
  the number of rows of \code{returns}.
}
\description{
Simulate (backtest) a rolling portfolio optimization strategy, using
\code{RcppArmadillo}.
}
\details{
The function \code{back_test()} performs a backtest simulation of a
  rolling portfolio optimization strategy over a \emph{vector} of
  \code{endp}.
  
  It performs a loop over the end points \code{endp}, and subsets the
  \emph{matrix} of excess returns \code{excess} along its rows, between the
  corresponding end point and the start point. It passes the subset matrix
  of excess returns into the function \code{calc_weights()}, which
  calculates the optimal portfolio weights. The arguments \code{eigen_max},
  \code{alpha}, \code{method}, and \code{scale} are also passed to the
  function \code{calc_weights()}.
  
  The function \code{back_test()} multiplies the weights by the coefficient
  \code{coeff} (with default equal to \code{1}), which allows reverting a
  strategy if \code{co_eff = -1}.
  
  The function \code{back_test()} then multiplies the weights times the
  future portfolio returns, to calculate the out-of-sample strategy returns.
  
  The function \code{back_test()} calculates the transaction costs by
  multiplying the bid-offer spread \code{bid_offer} times the absolute
  difference between the current weights minus the weights from the previous
  period. Then it subtracts the transaction costs from the out-of-sample
  strategy returns.
  
  The function \code{back_test()} returns a \emph{time series} (column
  \emph{vector}) of strategy returns, of the same length as the number of
  rows of \code{returns}.
}
\examples{
\dontrun{
# Calculate the ETF daily excess returns
re_turns <- na.omit(rutils::etf_env$re_turns[, 1:16])
# risk_free is the daily risk-free rate
risk_free <- 0.03/260
ex_cess <- re_turns - risk_free
# Define monthly end points without initial warmpup period
end_p <- rutils::calc_endpoints(re_turns, inter_val="months")
end_p <- end_p[end_p > 0]
len_gth <- NROW(end_p)
# Define 12-month look-back interval and start points over sliding window
look_back <- 12
start_p <- c(rep_len(1, look_back-1), end_p[1:(len_gth-look_back+1)])
# Define shrinkage and regularization intensities
al_pha <- 0.5
eigen_max <- 3
# Simulate a monthly rolling portfolio optimization strategy
pnl_s <- HighFreq::back_test(ex_cess, re_turns, 
                            start_p-1, end_p-1, 
                            eigen_max = eigen_max, 
                            alpha = al_pha)
pnl_s <- xts::xts(pnl_s, index(re_turns))
colnames(pnl_s) <- "strat_rets"
# Plot dygraph of strategy
dygraphs::dygraph(cumsum(pnl_s), 
  main="Cumulative Returns of Max Sharpe Portfolio Strategy")
}

}
