% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{push_sga}
\alias{push_sga}
\title{Update the trailing eigen values and eigen vectors of streaming asset return
data, with a row of new returns, using the \emph{SGA} algorithm.}
\usage{
push_sga(retsn, eigenval, eigenvec, eigenret, meanv, varv, lambda, gamma)
}
\arguments{
\item{\code{retsn}}{A \emph{vector} of new asset returns.}

\item{\code{eigenval}}{A \emph{vector} of eigen values.}

\item{\code{eigenvec}}{A \emph{matrix} of eigen vectors.}

\item{\code{eigenret}}{A \emph{vector} of eigen portfolio returns.}

\item{\code{meanv}}{A \emph{vector} of trailing means of asset returns.}

\item{\code{varv}}{A \emph{vector} of the trailing asset variances.}

\item{\code{lambda}}{A decay factor which multiplies the past
mean and variance.}

\item{\code{gamma}}{A \emph{numeric} gain factor which multiplies the past
eigenelements.}
}
\value{
Void (no return value - modifies the trailing eigen values, eigen
  vectors, the return means, and the return variances in place).
}
\description{
Update the trailing eigen values and eigen vectors of streaming asset return
data, with a row of new returns, using the \emph{SGA} algorithm.
}
\details{
The function \code{push_sga()} updates the trailing eigen values, eigen
  vectors, and the eigen portfolio returns of streaming asset returns, with
  a row of new data, using the \emph{SGA} algorithm. It updates the
  eigenelements in place, without copying the data in memory.
  
  The streaming asset returns \eqn{r_t} contain multiple columns and the
  parameter \code{retsn} represents a single row of \eqn{r_t} - the asset
  returns at time \eqn{t}.  The elements of the vectors \code{retsn},
  \code{meanv}, and \code{varv} represent single rows of data with multiple
  columns.
  
  The function \code{push_sga()} accepts \emph{pointers} to the arguments
  \code{eigenval}, \code{eigenvec}, \code{meanv}, and \code{varv},
  and it overwrites the old values with the new values. It performs the
  calculation in place, without copying the data in memory, which can
  significantly increase the computation speed for large matrices.

  First, the function \code{push_sga()} updates the trailing means
  \eqn{\bar{r}_t} and variances \eqn{\sigma^2_t} of the streaming asset
  returns \eqn{r_t} by recursively weighting present and past values
  using the decay factor \eqn{\lambda}:
  \deqn{
    \bar{r}_t = \lambda \bar{r}_{t-1} + (1-\lambda) r_t
  }
  \deqn{
    \sigma^2_t = \lambda \sigma^2_{t-1} + (1-\lambda) (r_t - \bar{r}_t)^2
  }
  The past values \eqn{\bar{r}_{t-1}} and \eqn{\sigma^2_{t-1}} are passed in
  by reference through the variables \code{meanv} and \code{varv}. The
  updated values are then passed out by reference.

  These recursive formulas are equivalent to the exponentially weighted
  moving averages of the streaming asset returns \eqn{r_t}.

  It then calculates a vector of the eigen portfolio returns:
  \deqn{
    r^{eigen}_t = \strong{v}_{t-1} \frac{r_t}{\sigma_{t-1}}
  }
  Where \eqn{\strong{v}_{t-1}} is the matrix of previous eigen vectors that
  are passed by reference through the parameter \code{eigenvec}. The eigen
  returns \eqn{r^{eigen}_t} are the returns of the eigen portfolios, with
  weights equal to the eigen vectors \eqn{\strong{v}_{t-1}}. The eigen
  weights are applied to the asset returns scaled by their volatilities.
  The eigen returns \eqn{r^{eigen}_t} are passed by reference through the
  parameter \code{eigenret}. 
  
  The function \code{push_sga()} then standardizes the columns of the new
  returns:
  \deqn{
    \hat{r}_t = \frac{r_t - \bar{r}_t}{\sigma_t}
  }
  
  Finally, the vector of eigen values \eqn{\Lambda_{j, t}} and the matrix of
  eigen vectors \eqn{\strong{v}_{j, t}} (\eqn{j} is the column index) are
  then updated using the \emph{SGA} algorithm:
  \deqn{
    \Lambda_{j, t} = (1-\gamma) \Lambda_{j, t-1} + \gamma \phi_{j, t-1}
  }
  \deqn{
    \strong{v}_{j, t} = \strong{v}_{j, t-1} + \gamma \phi_{j, t-1} (\hat{r}_{t} - \phi_{j, t-1} \strong{v}_{j, t-1} - 2 \sum_{i=1}^{j-1} \phi_{i, t-1} \strong{v}_{i, t-1})
  }
  Where \eqn{\phi_{j, t-1} = \hat{r}_{t} \strong{v}_{j, t-1}} are the matrix
  products of the new data times the previous eigen vectors. 
  
  The gain factor \eqn{\gamma} determines the strength of the updates, with
  larger \eqn{\gamma} values giving more weight to the new data. If the
  asset returns are not stationary, then applying more weight to the new
  returns reduces the bias of the trailing eigen vectors, but it also
  increases their variance. Simulation can be used to find the value of the
  \eqn{\gamma} parameter to achieve the best bias-variance tradeoff.
  
  A description of the \emph{SGA} algorithm can be found in the package
  \href{https://cran.r-project.org/web/packages/onlinePCA/index.html}{onlinePCA} and in the 
  \href{https://paperswithcode.com/paper/online-principal-component-analysis-in-high}{Online PCA paper}.
  
  The function \code{push_sga()} is written in \code{RcppArmadillo}
  \code{C++} code and it calls the \code{Armadillo} function
  \code{arma::qr_econ()} to perform the QR decomposition, to calculate the
  eigen vectors.
}
\examples{
\dontrun{
# Calculate a time series of returns
retsp <- na.omit(rutils::etfenv$returns[, c("IEF", "VTI", "DBC")])
# Calculate the covariance of returns without the last row
nrows <- NROW(retsp)
retss <- retsp[-nrows]
HighFreq::calc_scale(retss)
meanv <- colMeans(retss)
varv <- sapply(retss, var)
covmat <- cov(retss)
ncols <- NCOL(retss)
# Calculate the eigen decomposition using RcppArmadillo
eigenval <- numeric(ncols) # Allocate eigen values
eigenvec <- matrix(numeric(ncols^2), nc=ncols) # Allocate eigen vectors
HighFreq::calc_eigen(covmat, eigenval, eigenvec)
# Update the eigen decomposition using SGA
eigenret <- numeric(NCOL(retsp))
HighFreq::push_sga(retsn=retsp[nrows], 
  eigenval=eigenval, eigenvec=eigenvec, 
  eigenret=eigenret, meanv=meanv, varv=varv, lambda=0.9, gamma=0.1)
}

}
