% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HighFreq.R
\name{ohlc_variance}
\alias{ohlc_variance}
\title{Calculate a time series of point estimates of variance for an \emph{OHLC}
time series, using different range estimators for variance.}
\usage{
ohlc_variance(oh_lc, method = "yang_zhang", scal_e = TRUE)
}
\arguments{
\item{\code{oh_lc}}{An \emph{OHLC} time series of prices in \emph{xts} format.}

\item{\code{method}}{A \emph{character} string representing the method for
estimating variance.  The methods include:
\itemize{
  \item "close" close to close,
  \item "garman_klass" Garman-Klass,
  \item "garman_klass_yz" Garman-Klass with account for close-to-open price jumps,
  \item "rogers_satchell" Rogers-Satchell,
  \item "yang_zhang" Yang-Zhang,
 }
 (default is \code{"yang_zhang"})}

\item{\code{scal_e}}{\emph{Boolean} argument: should the returns be divided by the
number of seconds in each period? (default is \code{TRUE})}
}
\value{
An \emph{xts} time series with a single column and the same number of
  rows as the argument \code{oh_lc}.
}
\description{
Calculates the point variance estimates from individual rows of \emph{OHLC}
prices (rows of data), using the squared differences of \emph{OHLC} prices at
each point in time, without averaging them over time.
}
\details{
The function \code{ohlc_variance()} calculates a time series of point
  variance estimates of percentage returns, from \emph{OHLC} prices, without
  averaging them over time. For example, the method \code{"close"} simply
  calculates the squares of the differences of the log \emph{Close} prices.

  The other methods calculate the squares of other possible differences of
  the log \emph{OHLC} prices.  This way the point variance estimates only
  depend on the price differences within individual rows of data (and
  possibly from the neighboring rows.)
  All the methods are implemented assuming zero drift, since the calculations
  are performed only for a single row of data, at a single point in time.

  The user can choose from several different variance estimation methods. The
  methods \code{"close"}, \code{"garman_klass_yz"}, and \code{"yang_zhang"}
  do account for close-to-open price jumps, while the methods
  \code{"garman_klass"} and \code{"rogers_satchell"} do not account for
  close-to-open price jumps. The default method is \code{"yang_zhang"}, which
  theoretically has the lowest standard error among unbiased estimators.

  The point variance estimates can be passed into function \code{roll_vwap()}
  to perform averaging, to calculate rolling variance estimates.  This is
  appropriate only for the methods \code{"garman_klass"} and
  \code{"rogers_satchell"}, since they don't require subtracting the rolling
  mean from the point variance estimates.

  The point variance estimates can also be considered to be technical
  indicators, and can be used as inputs into trading models.

  If \code{scal_e} is \code{TRUE} (the default), then the variance is divided
  by the squared differences of the time index (which scales the variance to
  units of variance per second squared.) This is useful for example, when
  calculating intra-day variance from minutely bar data, because dividing
  returns by the number of seconds decreases the effect of overnight price
  jumps.

  If \code{scal_e} is \code{TRUE} (the default), then the variance is
  expressed in the scale of the time index of the \emph{OHLC} time series.
  For example, if the time index is in seconds, then the variance is given in
  units of variance per second squared.  If the time index is in days, then
  the variance is equal to the variance per day squared.

  The time index of the \code{oh_lc} time series is assumed to be in
  \emph{POSIXct} format, so that its internal value is equal to the number of
  seconds that have elapsed since the \emph{epoch}.

  The function \code{ohlc_variance()} performs similar calculations to the
  function \code{volatility()} from package
  \href{https://cran.r-project.org/web/packages/TTR/index.html}{TTR}, but it
  assumes zero drift, and doesn't calculate a running sum using
  \code{runSum()}.  It's also a little faster because it performs less data
  validation.
}
\examples{
# Create minutely OHLC time series of random prices
oh_lc <- HighFreq::random_ohlc()
# Calculate variance estimates for oh_lc
var_running <- HighFreq::ohlc_variance(oh_lc)
# Calculate variance estimates for SPY
var_running <- HighFreq::ohlc_variance(HighFreq::SPY, method="yang_zhang")
# Calculate SPY variance without overnight jumps
var_running <- HighFreq::ohlc_variance(HighFreq::SPY, method="rogers_satchell")
}
