% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_var}
\alias{run_var}
\title{Calculate the rolling variance of streaming \emph{time series} of returns.}
\usage{
run_var(tseries, lambda)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix} of returns.}

\item{\code{lambda}}{A \emph{numeric} decay factor.}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{tseries}.
}
\description{
Calculate the rolling variance of streaming \emph{time series} of returns.
}
\details{
The function \code{run_var()} calculates the rolling variance of a
  streaming \emph{time series} of returns by recursively weighing the
  squared present returns with past variance estimates, using the decay
  factor \eqn{\lambda}:
  \deqn{
    \sigma^2_t = (1-\lambda) r^2_t + \lambda \sigma^2_{t-1}
  }
  Where \eqn{\sigma^2_t} is the variance estimate at time \eqn{t}, and
  \eqn{r_t} are the streaming returns data.

  The above formula slightly overestimates the variance because it doesn't
  subtract the mean returns.

  The above recursive formula is convenient for processing live streaming
  data because it doesn't require maintaining a buffer of past data.
  The formula is equivalent to a convolution with exponentially decaying
  weights, but it's faster.

  The function \code{run_var()} performs the same calculation
  as the standard \code{R} function <br>\code{stats::filter(x=series,
  filter=weight_s, method="convolution", sides=1)}, but it's several
  times faster.

  The function \code{run_var()} returns a \emph{matrix} with the same
  dimensions as the input argument \code{tseries}.
}
\examples{
\dontrun{
# Calculate historical returns
re_turns <- zoo::coredata(na.omit(rutils::etf_env$re_turns$VTI))
# Calculate the rolling variance
lamb_da <- 0.9
vars <- HighFreq::run_var(re_turns, lambda=lamb_da)
# Calculate rolling variance using R code
filter_ed <- (1-lamb_da)*filter(re_turns^2, filter=lamb_da, init=as.numeric(re_turns[1, 1])^2/(1-lamb_da), method="recursive")
all.equal(vars, unclass(filter_ed), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::run_var(re_turns, lambda=lamb_da),
  Rcode=filter(re_turns^2, filter=lamb_da, init=as.numeric(re_turns[1, 1])^2/(1-lamb_da), method="recursive"),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
