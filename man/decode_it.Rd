% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{decode_it}
\alias{decode_it}
\title{Calculate the \emph{vector} of data from its run length encoding.}
\usage{
decode_it(encodel)
}
\arguments{
\item{\code{encodel}}{A \emph{list} with two \emph{vectors}: a \emph{numeric
vector} of encoded data and an \emph{integer vector} of data counts
(repeats).}
}
\value{
A \code{numeric vector}.
}
\description{
Calculate the \emph{vector} of data from its run length encoding.
}
\details{
The function \code{decode_it()} the \emph{vector} of data from its run
  length encoding.
  
  The run length encoding of a \emph{vector} consists of two \emph{vectors}:
  a \emph{numeric vector} of encoded data (consecutive data values) and of
  an \emph{integer vector} of the data counts (the number of times the same
  value repeats in succession).
  
  Run length encoding (RLE) is a data compression algorithm which encodes
  the data in two \emph{vectors}: the consecutive data values and their
  counts.  If a data value occurs several times in succession then it is
  recorded only once and its corresponding count is equal to the number of
  times it occurs. Run-length encoding is different from a contingency
  table.
}
\examples{
\dontrun{
# Create a vector of data
datav <- sample(5, 31, replace=TRUE)
# Calculate the run length encoding of datav
rle <- HighFreq::encode_it(datav)
# Decode the data from its run length encoding
decodev <- HighFreq::decode_it(rle)
all.equal(datav, decodev)
}

}
