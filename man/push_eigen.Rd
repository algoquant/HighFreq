% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{push_eigen}
\alias{push_eigen}
\title{Update the trailing eigen values and eigen vectors of streaming asset return
data, with a row of new returns.}
\usage{
push_eigen(retsn, covmat, eigenval, eigenvec, eigenret, meanv, lambdacov)
}
\arguments{
\item{\code{retsn}}{A \emph{vector} of new asset returns.}

\item{\code{covmat}}{A trailing covariance \emph{matrix} of asset returns.}

\item{\code{eigenval}}{A \emph{vector} of eigen values.}

\item{\code{eigenvec}}{A \emph{matrix} of eigen vectors.}

\item{\code{eigenret}}{A \emph{vector} of eigen portfolio returns.}

\item{\code{meanv}}{A \emph{vector} of trailing means of asset returns.}

\item{\code{lambdacov}}{A decay factor which multiplies the past covariance.}
}
\value{
Void (no return value - modifies the trailing eigen values, eigen
  vectors, the eigen portfolio returns, and the return means in place).
}
\description{
Update the trailing eigen values and eigen vectors of streaming asset return
data, with a row of new returns.
}
\details{
The function \code{push_eigen()} updates the trailing eigen values, eigen
  vectors, and the eigen portfolio returns of streaming asset returns, with
  a row of new data.  It updates the eigenelements in place, without copying
  the data in memory.
  
  The streaming asset returns \eqn{r_t} contain multiple columns and the
  parameter \code{retsn} represents a single row of \eqn{r_t} - the asset
  returns at time \eqn{t}.  The elements of the vectors \code{retsn},
  \code{eigenret}, and \code{meanv} represent single rows of data with
  multiple columns.
  
  The function \code{push_eigen()} accepts \emph{pointers} to the arguments
  \code{eigenval}, \code{eigenval}, \code{eigenvec}, \code{meanv}, and
  \code{eigenret}, and it overwrites the old values with the new values. It
  performs the calculation in place, without copying the data in memory,
  which can significantly increase the computation speed for large matrices.

  First, the function \code{push_eigen()} calls the function
  \code{HighFreq::push_covar()} to update the trailing covariance matrix of
  streaming asset returns, with a row of new returns.  It updates the
  covariance matrix in place, without copying the data in memory.
  
  It then calls the \code{Armadillo} function \code{arma::eig_sym} to
  calculate the eigen decomposition of the trailing covariance matrix.
  
  The function \code{push_eigen()} calculates the eigen portfolio returns by
  multiplying the scaled asset returns times the eigen vectors
  \eqn{\strong{v}_{t-1}}:
  \deqn{
    r^{eigen}_t = \strong{v}_{t-1} \frac{r_t}{\sigma_{t-1}}
  }
  Where \eqn{\strong{v}_{t-1}} is the matrix of previous eigen vectors that
  are passed by reference through the parameter \code{eigenvec}. The eigen
  returns \eqn{r^{eigen}_t} are the returns of the eigen portfolios, with
  weights equal to the eigen vectors \eqn{\strong{v}_{t-1}}. The eigen
  weights are applied to the asset returns scaled by their volatilities.
  The eigen returns \eqn{r^{eigen}_t} are passed by reference through the
  parameter \code{eigenret}. 
  
  The decay factor \eqn{\lambda} determines the strength of the updates,
  with smaller \eqn{\lambda} values giving more weight to the new data. If
  the asset returns are not stationary, then applying more weight to the new
  returns reduces the bias of the trailing covariance matrix, but it also
  increases its variance. Simulation can be used to find the value of the
  \eqn{\lambda} parameter to achieve the best bias-variance tradeoff.
  
  The function \code{push_eigen()} is written in \code{RcppArmadillo}
  \code{C++} so it's much faster than \code{R} code.
}
\examples{
\dontrun{
# Calculate a time series of returns
retp <- na.omit(rutils::etfenv$returns[, c("IEF", "VTI", "DBC")])
# Calculate the returns without the last row
nrows <- NROW(retp)
retss <- retp[-nrows]
# Calculate the previous covariance of returns
meanv <- colMeans(retss)
covmat <- cov(retss)
# Update the covariance of returns
eigenret <- numeric(NCOL(retp))
HighFreq::push_eigen(retsn=retp[nrows], covmat=covmat, 
  eigenval=eigenval, eigenvec=eigenvec, 
  eigenret=eigenret, meanv=meanv, lambdacov=0.9)
}  # end dontrun

}
