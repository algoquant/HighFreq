% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_conv}
\alias{roll_conv}
\title{Calculate the rolling convolutions (weighted sums) of a \emph{time series}
with a \emph{column vector} of weights.}
\usage{
roll_conv(tseries, weights)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix} of data.}

\item{\code{weights}}{A \emph{column vector} of weights.}
}
\value{
A \emph{matrix} with the same dimensions as the input
  argument \code{tseries}.
}
\description{
Calculate the rolling convolutions (weighted sums) of a \emph{time series}
with a \emph{column vector} of weights.
}
\details{
The function \code{roll_conv()} calculates the convolutions of the
  \emph{matrix} columns with a \emph{column vector} of weights.  It performs
  a loop over the \emph{matrix} rows and multiplies the past (higher) values
  by the weights.  It calculates the rolling weighted sums of the past
  values.
  
  The function \code{roll_conv()} uses the \code{RcppArmadillo} function
  \code{arma::conv2()}. It performs a similar calculation to the standard
  \code{R} function \cr\code{filter(x=tseries, filter=weight_s,
  method="convolution", sides=1)}, but it's over \code{6} times faster, and
  it doesn't produce any leading \code{NA} values.
}
\examples{
\dontrun{
# First example
# Calculate a time series of prices
re_turns <- na.omit(rutils::etf_env$re_turns[, c("IEF", "VTI")])
# Create simple weights equal to a 1 value plus zeros
weight_s <- matrix(c(1, rep(0, 10)), nc=1)
# Calculate rolling weighted sums
weight_ed <- HighFreq::roll_conv(re_turns, weight_s)
# Compare with original
all.equal(coredata(re_turns), weight_ed, check.attributes=FALSE)
# Second example
# Calculate exponentially decaying weights
weight_s <- exp(-0.2*(1:11))
weight_s <- matrix(weight_s/sum(weight_s), nc=1)
# Calculate rolling weighted sums
weight_ed <- HighFreq::roll_conv(re_turns, weight_s)
# Calculate rolling weighted sums using filter()
filter_ed <- filter(x=re_turns, filter=weight_s, method="convolution", sides=1)
# Compare both methods
all.equal(filter_ed[-(1:11), ], weight_ed[-(1:11), ], check.attributes=FALSE)
}

}
