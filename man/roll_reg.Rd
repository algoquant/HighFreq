% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_reg}
\alias{roll_reg}
\title{Calculate a \emph{matrix} of regression coefficients, their t-values, and
z-scores, at the end points of the predictor matrix.}
\usage{
roll_reg(
  response,
  predictor,
  intercept = FALSE,
  startp = 0L,
  endp = 0L,
  step = 1L,
  look_back = 1L,
  stub = 0L,
  method = "least_squares",
  eigen_thresh = 1e-05,
  eigen_max = 0L,
  conf_lev = 0.1,
  alpha = 0
)
}
\arguments{
\item{\code{response}}{A single-column \emph{time series} or a \emph{vector}
of response data.}

\item{\code{predictor}}{A \emph{time series} or a \emph{matrix} of predictor
data.}

\item{\code{startp}}{An \emph{integer} vector of start points (the default
is \code{startp = 0}).}

\item{\code{endp}}{An \emph{integer} vector of end points (the default is 
\code{endp = 0}).}

\item{\code{step}}{The number of time periods between the end points (the
default is \code{step = 1}).}

\item{\code{look_back}}{The number of end points in the look-back interval
(the default is \code{look_back = 1}).}

\item{\code{stub}}{An \emph{integer} value equal to the first end point for
calculating the end points (the default is \code{stub = 0}).}

\item{\code{intercept}}{A \emph{Boolean} specifying whether an intercept
term should be added to the predictor (the default is \code{intercept =
FALSE}).}

\item{\code{method}}{A \emph{string} specifying the type of the regression
model the default is \code{method = "least_squares"} - see Details).}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small singular values in order to regularize the inverse of the
\code{predictor} matrix (the default is \code{1e-5}).}

\item{\code{eigen_max}}{An \emph{integer} equal to the number of singular
values used for calculating the shrinkage inverse of the \code{predictor}
matrix (the default is \code{0} - equivalent to \code{eigen_max} equal to
the number of columns of \code{predictor}).}

\item{\code{conf_lev}}{The confidence level for calculating the
quantiles (the default is \code{conf_lev = 0.75}).}

\item{\code{alpha}}{The shrinkage intensity between \code{0} and \code{1}.
(the default is \code{0}).}
}
\value{
A \emph{matrix} with the regression coefficients, their t-values, and
z-scores, and with the 
same number of rows as \code{predictor}
a
  number of columns equal to \code{2n+3}, where \code{n} is the number of
  columns of \code{predictor}.
}
\description{
Calculate a \emph{matrix} of regression coefficients, their t-values, and
z-scores, at the end points of the predictor matrix.
}
\details{
The function \code{roll_reg()} calculates a \emph{matrix} of regression
  coefficients, their t-values, and z-scores at the end points of the predictor
  matrix.
  
  The function \code{roll_reg()} performs a loop over the end points, and at
  each end point it subsets the time series \code{predictor} over a look-back
  interval equal to \code{look_back} number of end points.
  
  If the arguments \code{endp} and \code{startp} are not given then it
  first calculates a vector of end points separated by \code{step} time
  periods. It calculates the end points along the rows of \code{predictor}
  using the function \code{calc_endpoints()}, with the number of time
  periods between the end points equal to \code{step} time periods.
  
  For example, the rolling regression at \code{25} day end points, with a
  \code{75} day look-back, can be calculated using the parameters
  \code{step = 25} and \code{look_back = 3}.

  It passes the subset time series to the function \code{calc_reg()}, which
  calculates the regression coefficients, their t-values, and the z-score.
  
  If \code{intercept = TRUE} then an extra intercept column (unit column) is
  added to the predictor matrix (the default is \code{intercept = FALSE}).
  
  The number of columns of the return matrix depends on the number of
  columns of the \code{predictor} matrix (including the intercept column, if
  it's added).
  The number of columns of the return matrix is equal to the number of
  regression coefficients, plus their t-values, plus the z-score column.
  The number of regression coefficients is equal to the number of columns of
  the \code{predictor} matrix (including the intercept column, if it's
  added).
  The number of t-values is equal to the number of coefficients.
  For example, if the number of columns of the \code{predictor} matrix is
  equal to \code{n}, and if \code{intercept = TRUE}, then \code{roll_reg()}
  returns a matrix with \code{2n+3} columns: \code{n+1} regression
  coefficients (including the intercept coefficient), \code{n+1}
  corresponding t-values, and \code{1} z-score column.
}
\examples{
\dontrun{
# Calculate historical returns
returns <- na.omit(rutils::etfenv$returns[, c("XLP", "VTI")])
# Define monthly end points and start points
endp <- xts::endpoints(returns, on="months")[-1]
look_back <- 12
startp <- c(rep(1, look_back), endp[1:(NROW(endp)-look_back)])
# Calculate rolling betas using RcppArmadillo
reg_stats <- HighFreq::roll_reg(response=returns[, 1], predictor=returns[, 2], endp=(endp-1), startp=(startp-1))
betas <- reg_stats[, 2]
# Calculate rolling betas in R
betas_r <- sapply(1:NROW(endp), FUN=function(ep) {
  datav <- returns[startp[ep]:endp[ep], ]
  drop(cov(datav[, 1], datav[, 2])/var(datav[, 2]))
})  # end sapply
# Compare the outputs of both functions
all.equal(betas, betas_r, check.attributes=FALSE)
}

}
