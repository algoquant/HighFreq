% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_covar}
\alias{calc_covar}
\title{Calculate the covariance matrix of the columns of a \emph{time series}
using \code{RcppArmadillo}.}
\usage{
calc_covar(tseries, method = "moment", confl = 0.75)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix} of data.}

\item{\code{method}}{A \emph{character string} specifying the type of the
covariance model (the default is \code{method = "moment"} - see Details).}

\item{\code{confl}}{The confidence level for calculating the quantiles of
returns (the default is \code{confl = 0.75}).}
}
\value{
A square matrix with the covariance coefficients of the columns of
  the \emph{time series} \code{tseries}.
}
\description{
Calculate the covariance matrix of the columns of a \emph{time series}
using \code{RcppArmadillo}.
}
\details{
The function \code{calc_covar()} calculates the covariance matrix of the
  columns of a \emph{time series} or a \emph{matrix} of data using
  \code{RcppArmadillo} \code{C++} code.
  The covariance is a measure of the codependency of the data.

  If \code{method = "moment"} (the default) then \code{calc_covar()}
  calculates the covariance as the second co-moment:
  \deqn{
    \sigma_{xy} = \frac{1}{n-1} \sum_{i=1}^n (x_i - \bar{x}) (y_i - \bar{y})
  }
  Then \code{calc_covar()} performs the same calculation as the \code{R}
  function \code{stats::cov()}.

  If \code{method = "quantile"} then it calculates the covariance as the
  difference between the quantiles as follows:
  \deqn{
    \mu = q_{\alpha} - q_{1-\alpha}
  }
  Where \eqn{\alpha} is the confidence level for calculating the quantiles.
  
  If \code{method = "nonparametric"} then it calculates the covariance as the
  Median Absolute Deviation (\emph{MAD}):
  \deqn{
    MAD = median(abs(x - median(x)))
  }
  It also multiplies the \emph{MAD} by a factor of \code{1.4826}, to make it
  comparable to the standard deviation.

  If \code{method = "nonparametric"} then \code{calc_covar()} performs the
  same calculation as the function \code{stats::mad()}, but it's much faster
  because it uses \code{RcppArmadillo} \code{C++} code.

  If the number of rows of \code{tseries} is less than \code{3} then it
  returns zeros.
}
\examples{
\dontrun{
# Calculate VTI and XLF returns
retsp <- na.omit(rutils::etfenv$returns[, c("VTI", "XLF")])
# Compare HighFreq::calc_covar() with standard var()
all.equal(drop(HighFreq::calc_covar(retsp)), 
  cov(retsp), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with matrixStats and with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::calc_covar(retsp),
  Rcode=cov(retsp),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
# Compare HighFreq::calc_covar() with stats::mad()
all.equal(drop(HighFreq::calc_covar(retsp, method="nonparametric")), 
  sapply(retsp, mad), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with stats::mad()
summary(microbenchmark(
  Rcpp=HighFreq::calc_covar(retsp, method="nonparametric"),
  Rcode=sapply(retsp, mad),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
