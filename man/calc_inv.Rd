% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_inv}
\alias{calc_inv}
\title{Calculate the regularized inverse of a rectangular \emph{matrix} of data
using Singular Value Decomposition (\emph{SVD}).}
\usage{
calc_inv(tseries, eigen_thresh = 0.001, eigen_max = 0L)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or \emph{matrix} of returns data.}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small singular values in order to regularize the inverse of the
matrix \code{tseries} (the default is \code{0.001}).}

\item{\code{eigen_max}}{An \emph{integer} equal to the number of singular
values used for calculating the regularized inverse of the matrix
\code{tseries} (the default is \code{0} - equivalent to \code{eigen_max}
equal to the number of columns of \code{tseries}).}
}
\value{
A \emph{matrix} equal to the regularized inverse of the matrix
  \code{tseries}.
}
\description{
Calculate the regularized inverse of a rectangular \emph{matrix} of data
using Singular Value Decomposition (\emph{SVD}).
}
\details{
The function calc_inv() calculates the regularized inverse of
  \code{tseries} using Singular Value Decomposition (\emph{SVD}).
  
  If \code{eigen_max} is given, then it calculates the regularized inverse
  from the \emph{SVD} using the first \code{eigen_max} largest singular
  values.  For example, if \code{eigen_max = 3} then it only uses the
  \code{3} largest singular values.
  If \code{eigen_max} is set equal to the number of columns of
  \code{tseries} then it uses all the singular values without any
  regularization.

  If \code{eigen_max} is not given then it calculates the regularized
  inverse using the function \code{arma::pinv()}. It then discards small
  singular values that are less than the threshold level
  \code{eigen_thresh}.
}
\examples{
\dontrun{
# Calculate ETF returns
re_turns <- na.omit(rutils::etf_env$re_turns)
# Calculate regularized inverse using RcppArmadillo
in_verse <- HighFreq::calc_inv(re_turns, eigen_max=3)
# Calculate regularized inverse from SVD in R
s_vd <- svd(re_turns)
eigen_max <- 1:3
inverse_r <-  s_vd$v[, eigen_max] \%*\% (t(s_vd$u[, eigen_max]) / s_vd$d[eigen_max])
# Compare RcppArmadillo with R
all.equal(in_verse, inverse_r)
}

}
