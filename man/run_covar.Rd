% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_covar}
\alias{run_covar}
\title{Calculate the rolling covariance of two streaming \emph{time series} of
returns.}
\usage{
run_covar(tseries, lambda)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix} with two
columns of returns data.}

\item{\code{lambda}}{A \emph{numeric} decay factor.}
}
\value{
A \emph{matrix} with three columns of data: the covariance and the
  variances of the two columns of the argument \code{tseries}.
}
\description{
Calculate the rolling covariance of two streaming \emph{time series} of
returns.
}
\details{
The function \code{run_covar()} calculates the rolling covariance of 
  two streaming \emph{time series} of returns by recursively weighing the
  products of their present returns with past covariance estimates, using
  the decay factor \eqn{\lambda}:
  \deqn{
    \sigma^2_t = (1-\lambda) r1_t r2_t + \lambda \sigma^2_{t-1}
  }
  Where \eqn{\sigma^2_t} is the covariance estimate at time \eqn{t}, and
  \eqn{r1_t} and \eqn{r2_t} are the streaming returns data.

  The above formula slightly overestimates the covariance because it doesn't
  subtract the mean returns.

  The above recursive formula is convenient for processing live streaming
  data because it doesn't require maintaining a buffer of past data.
  The formula is equivalent to a convolution with exponentially decaying
  weights, but it's faster.

  The function \code{run_covar()} returns three columns of data: the
  covariance and the variances of the two columns of the argument
  \code{tseries}.  This allows calculating the rolling correlation.

  The function \code{run_covar()} performs the same calculation
  as the standard \code{R} function <br>\code{stats::filter(x=series,
  filter=weight_s, method="convolution", sides=1)}, but it's several
  times faster.
}
\examples{
\dontrun{
# Calculate historical returns
re_turns <- zoo::coredata(na.omit(rutils::etf_env$re_turns[, c("IEF", "VTI")]))
# Calculate the rolling covariance
lamb_da <- 0.9
covars <- HighFreq::run_covar(re_turns, lambda=lamb_da)
# Calculate rolling covariance using R code
filter_ed <- (1-lamb_da)*filter(re_turns[, 1]*re_turns[, 2], filter=lamb_da, init=as.numeric(re_turns[1, 1]*re_turns[1, 2])/(1-lamb_da), method="recursive")
all.equal(covars[, 1], unclass(filter_ed), check.attributes=FALSE)
# Calculate the rolling correlation
correl <- covars[, 1]/sqrt(covars[, 2]*covars[, 3])
}

}
