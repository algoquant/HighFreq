% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_covar}
\alias{run_covar}
\title{Calculate the trailing covariances of two streaming \emph{time series} of
returns using an online recursive formula.}
\usage{
run_covar(tseries, lambda)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix} with two
columns of returns data.}

\item{\code{lambda}}{A decay factor which multiplies past estimates.}
}
\value{
A \emph{matrix} with five columns of data: the trailing covariances,
  the variances, and the mean values of the two columns of the argument
  \code{tseries}.
}
\description{
Calculate the trailing covariances of two streaming \emph{time series} of
returns using an online recursive formula.
}
\details{
The function \code{run_covar()} calculates the trailing covariances of two
  streaming \emph{time series} of returns, by recursively weighting the past
  covariance estimates \eqn{{cov}_{t-1}}, with the products of their
  returns minus their means, using the decay factor \eqn{\lambda}:
  \deqn{
    \bar{x}_t = \lambda \bar{x}_{t-1} + (1-\lambda) x_t
  }
  \deqn{
    \bar{y}_t = \lambda \bar{y}_{t-1} + (1-\lambda) y_t
  }
  \deqn{
    \sigma^2_{x t} = \lambda \sigma^2_{x t-1} + (1-\lambda) (x_t - \bar{x}_t)^2
  }
  \deqn{
    \sigma^2_{y t} = \lambda \sigma^2_{y t-1} + (1-\lambda) (y_t - \bar{y}_t)^2
  }
  \deqn{
    {cov}_t = \lambda {cov}_{t-1} + (1-\lambda) (x_t - \bar{x}_t) (y_t - \bar{y}_t)
  }
  Where \eqn{{cov}_t} is the trailing covariance estimate at time \eqn{t},
  \eqn{\sigma^2_{x t}}, \eqn{\sigma^2_{y t}}, \eqn{\bar{x}_t} and
  \eqn{\bar{x}_t} are the trailing variances and means of the returns, and
  \eqn{x_t} and \eqn{y_t} are the two streaming returns data.

  The above online recursive formulas are convenient for processing live
  streaming data because they don't require maintaining a buffer of past
  data. The formulas are equivalent to a convolution with exponentially
  decaying weights, but they're much faster to calculate.
  Using exponentially decaying weights is more natural than using a sliding
  look-back interval, because it gradually "forgets" about the past data.

  The value of the decay factor \eqn{\lambda} must be in the range between
  \code{0} and \code{1}.  
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, and the trailing covariance values have a
  stronger dependence on past data.  This is equivalent to a long
  look-back interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, and the trailing covariance values have
  a weaker dependence on past data.  This is equivalent to a short
  look-back interval.

  The function \code{run_covar()} returns five columns of data: the trailing 
  covariances, the variances, and the mean values of the two columns of the
  argument \code{tseries}.  This allows calculating the trailing
  correlations, betas, and alphas.
}
\examples{
\dontrun{
# Calculate historical returns
retp <- zoo::coredata(na.omit(rutils::etfenv$returns[, c("IEF", "VTI")]))
# Calculate the trailing covariance
lambda <- 0.9
covars <- HighFreq::run_covar(retp, lambda=lambda)
# Calculate the trailing correlation
correl <- covars[, 1]/sqrt(covars[, 2]*covars[, 3])
# Calculate the trailing covariance using R code
nrows <- NROW(retp)
retm <- matrix(numeric(2*nrows), nc=2)
retm[1, ] <- retp[1, ]
retd <- matrix(numeric(2*nrows), nc=2)
covarr <- numeric(nrows)
covarr[1] <- retp[1, 1]*retp[1, 2]
for (it in 2:nrows) {
  retm[it, ] <- lambda*retm[it-1, ] + (1-lambda)*(retp[it, ])
  retd[it, ] <- retp[it, ] - retm[it, ]
  covarr[it] <- lambda*covarr[it-1] + (1-lambda)*retd[it, 1]*retd[it, 2]
} # end for
all.equal(covars[, 1], covarr, check.attributes=FALSE)
}

}
