% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{push_covar}
\alias{push_covar}
\title{Update the trailing covariance matrix of streaming asset returns,
with a row of new returns.}
\usage{
push_covar(retsn, covmat, meanv, lambdacov)
}
\arguments{
\item{\code{retsn}}{A \emph{vector} of new asset returns.}

\item{\code{covmat}}{A trailing covariance \emph{matrix} of asset returns.}

\item{\code{meanv}}{A \emph{vector} of trailing means of asset returns.}

\item{\code{lambdacov}}{A decay factor which multiplies the past covariance.}
}
\value{
Void (no return value - modifies the trailing covariance matrix
  and the return means in place).
}
\description{
Update the trailing covariance matrix of streaming asset returns,
with a row of new returns.
}
\details{
The function \code{push_covar()} updates the trailing covariance matrix of
  streaming asset returns, with a row of new returns.  It updates the
  covariance matrix in place, without copying the data in memory.
  
  The streaming asset returns \eqn{r_t} contain multiple columns and the
  parameter \code{retsn} represents a single row of \eqn{r_t} - the asset
  returns at time \eqn{t}.  The elements of the vectors \code{retsn} and 
  \code{meanv} represent single rows of data with multiple columns.
  
  The function \code{push_covar()} accepts \emph{pointers} to the arguments
  \code{covmat} and \code{meanv}, 
  and it overwrites the old values with the new values. It performs the
  calculation in place, without copying the data in memory, which can
  significantly increase the computation speed for large matrices.

  First, the function \code{push_covar()} updates the trailing means
  \eqn{\bar{r}_t} of the streaming asset returns \eqn{r_t} by recursively
  weighting present and past values using the decay factor \eqn{\lambda}:
  \deqn{
    \bar{r}_t = \lambda \bar{r}_{t-1} + (1-\lambda) r_t
  }
  This recursive formula is equivalent to the exponentially weighted moving
  average of the streaming asset returns \eqn{r_t}.

  It then calculates the demeaned returns:
  \deqn{
    \hat{r}_t = r_t - \bar{r}_t
  }
  
  Finally, it updates the trailing covariance matrix of the returns:
  \deqn{
    cov_t = \lambda cov_{t-1} + (1-\lambda) \hat{r}^T_t \hat{r}_t
  }
  
  The decay factor \eqn{\lambda} determines the strength of the updates,
  with smaller \eqn{\lambda} values giving more weight to the new data. If
  the asset returns are not stationary, then applying more weight to the new
  returns reduces the bias of the trailing covariance matrix, but it also
  increases its variance. Simulation can be used to find the value of the
  \eqn{\lambda} parameter to achieve the best bias-variance tradeoff.
  
  The function \code{push_covar()} is written in \code{RcppArmadillo}
  \code{C++} so it's much faster than \code{R} code.
}
\examples{
\dontrun{
# Calculate a time series of returns
retsp <- na.omit(rutils::etfenv$returns[, c("IEF", "VTI", "DBC")])
# Calculate the returns without last row
nrows <- NROW(retsp)
retss <- retsp[-nrows]
# Calculate the covariance of returns
meanv <- colMeans(retss)
covmat <- cov(retss)
# Update the covariance of returns
HighFreq::push_covar(retsn=retsp[nrows], covmat=covmat, meanv=meanv, lambdacov=0.9)
}

}
