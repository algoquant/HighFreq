% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_mean}
\alias{roll_mean}
\title{Calculate a \emph{matrix} of mean (location) estimates over a rolling
look-back interval attached at the end points of a \emph{time series} or a
\emph{matrix}.}
\usage{
roll_mean(
  tseries,
  startp = 0L,
  endp = 0L,
  step = 1L,
  look_back = 1L,
  stub = 0L,
  method = "moment",
  con_fi = 0.75
)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix} of data.}

\item{\code{startp}}{An \emph{integer} vector of start points (the default
is \code{startp = 0}).}

\item{\code{endp}}{An \emph{integer} vector of end points (the default is
\code{endp = 0}).}

\item{\code{step}}{The number of time periods between the end points (the
default is \code{step = 1}).}

\item{\code{look_back}}{The number of end points in the look-back interval
(the default is \code{look_back = 1}).}

\item{\code{stub}}{An \emph{integer} value equal to the first end point for
calculating the end points (the default is \code{stub = 0}).}

\item{\code{method}}{A \emph{character} string representing the type of mean 
measure of (the default is \code{method = "moment"}).}
}
\value{
A \emph{matrix} of mean (location) estimates with the same number of
  columns as the input time series \code{tseries}, and the number of rows
  equal to the number of end points.
}
\description{
Calculate a \emph{matrix} of mean (location) estimates over a rolling
look-back interval attached at the end points of a \emph{time series} or a
\emph{matrix}.
}
\details{
The function \code{roll_mean()} calculates a \emph{matrix} of mean
  (location) estimates over rolling look-back intervals attached at the end
  points of the \emph{time series} \code{tseries}.
  
  The function \code{roll_mean()} performs a loop over the end points, and at
  each end point it subsets the time series \code{tseries} over a look-back
  interval equal to \code{look_back} number of end points.
  
  It passes the subset time series to the function \code{calc_mean()}, which
  calculates the mean (location).
  See the function \code{calc_mean()} for a description of the mean methods.
  
  If the arguments \code{endp} and \code{startp} are not given then it
  first calculates a vector of end points separated by \code{step} time
  periods. It calculates the end points along the rows of \code{tseries}
  using the function \code{calc_endpoints()}, with the number of time
  periods between the end points equal to \code{step} time periods.

  For example, the rolling mean at \code{25} day end points, with a
  \code{75} day look-back, can be calculated using the parameters
  \code{step = 25} and \code{look_back = 3}.

  The function \code{roll_mean()} with the parameter \code{step = 1}
  performs the same calculation as the function \code{roll_mean()} from
  package
  \href{https://cran.r-project.org/web/packages/RcppRoll/index.html}{RcppRoll},
  but it's several times faster because it uses \code{RcppArmadillo}
  \code{C++} code.

  The function \code{roll_mean()} is implemented in \code{RcppArmadillo}
  \code{C++} code, so it's many times faster than the equivalent \code{R}
  code.

  If only a simple rolling mean is required (not the median) then other
  functions like \code{roll_sum()} or \code{roll_vec()} may be even faster.
}
\examples{
\dontrun{
# Define time series of returns using package rutils
re_turns <- na.omit(rutils::etf_env$re_turns$VTI)
# Calculate the rolling means at 25 day end points, with a 75 day look-back
means <- HighFreq::roll_mean(re_turns, step=25, look_back=3)
# Compare the mean estimates over 11-period lookback intervals
all.equal(HighFreq::roll_mean(re_turns, look_back=11)[-(1:10), ], 
  drop(RcppRoll::roll_mean(re_turns, n=11)), check.attributes=FALSE)
# Define end points and start points
end_p <- HighFreq::calc_endpoints(NROW(re_turns), step=25)
start_p <- HighFreq::calc_startpoints(end_p, look_back=3)
# Calculate the rolling means using RcppArmadillo
means <- HighFreq::roll_mean(re_turns, startp=start_p, endp=end_p)
# Calculate the rolling medians using RcppArmadillo
medianscpp <- HighFreq::roll_mean(re_turns, startp=start_p, endp=end_p, method="nonparametric")
# Calculate the rolling medians using R
medians = sapply(1:NROW(end_p), function(i) {
  median(re_turns[start_p[i]:end_p[i] + 1])
})  # end sapply
all.equal(medians, drop(medianscpp))
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::roll_mean(re_turns, startp=start_p, endp=end_p, method="nonparametric"),
  Rcode=sapply(1:NROW(end_p), function(i) {median(re_turns[start_p[i]:end_p[i] + 1])}),
  times=10))[, c(1, 4, 5)]
}
}
