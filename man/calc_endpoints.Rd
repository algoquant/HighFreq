% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_endpoints}
\alias{calc_endpoints}
\title{Calculate a vector of end points that divides a vector into equal intervals.}
\usage{
calc_endpoints(length, step = 1L, front = TRUE)
}
\arguments{
\item{\code{length}}{An \emph{integer} equal to the length of the vector to
be divided into equal intervals.}

\item{\code{step}}{The number of elements in each interval between
neighboring end points.}

\item{\code{front}}{\emph{Boolean} argument: if \code{TRUE} then add a stub
interval at the beginning, else add a stub interval at the end.  (default
is \code{TRUE})}
}
\value{
A vector of equally spaced index values representing the end points
  (a vector of unsigned integers).
}
\description{
Calculate a vector of end points that divides a vector into equal intervals.
}
\details{
The end points are a vector of unsigned integers which divide a vector of
  length equal to \code{length} into equally spaced intervals. If a whole
  number of intervals doesn't fit over the vector, then
  \code{calc_endpoints()} adds a stub interval either at the beginning (the
  default) or at the end.

  The end points are shifted by \code{-1} compared to \code{R} code because
  indexing starts at \code{0} in \code{C++} code, while it starts at
  \code{1} in \code{R} code.
  So if \code{calc_endpoints()} is used in \code{R} code then \code{1}
  should be added to it.

  The function \code{calc_endpoints()} is similar to the function
  \code{rutils::calc_endpoints()} from package
  \href{https://github.com/algoquant/rutils}{rutils}.
  
  The end points produced by \code{calc_endpoints()} don't include the first
  placeholder end point, which is usually equal to zero.
  For example, consider the end points for a vector of length \code{20}
  divided into intervals of length \code{5}: \code{0, 5, 10, 15, 20}.
  In order for all the differences between neighboring end points to be
  equal to \code{5}, the first end point must be equal to \code{0}.
  The first end point is a placeholder and doesn't correspond to any vector
  element.
  
  This works in \code{R} code because the vector element corresponding to
  index \code{0} is empty.  For example, the \code{R} code: \code{(4:1)[c(0,
  1)]} produces \code{4}.  So in \code{R} we can select vector elements
  using the end points starting at zero.
  
  In \code{C++} the end points must be shifted by \code{-1} because indexing
  starts at \code{0}: \code{-1, 4, 9, 14, 19}.  But there is no vector
  element corresponding to index \code{-1}. So in \code{C++} we cannot
  select vector elements using the end points starting at \code{-1}. The
  solution is to drop the first placeholder end point.
}
\examples{
# Calculate end points without a stub interval
HighFreq::calc_endpoints(25, 5)
# Calculate end points with initial stub interval
HighFreq::calc_endpoints(23, 5)
# Calculate end points with a stub interval at the end
HighFreq::calc_endpoints(23, 5, FALSE)

}
