% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{sim_schwartz}
\alias{sim_schwartz}
\title{Simulate a \emph{Schwartz} process using \emph{Rcpp}.}
\usage{
sim_schwartz(eq_price, volat, theta, innov)
}
\arguments{
\item{\code{volat}}{The volatility of returns.}

\item{\code{eq_price}}{The equilibrium price.}

\item{\code{theta}}{The strength of mean reversion.}

\item{\code{innov}}{A single-column \emph{matrix} of innovations (random
numbers).}
}
\value{
A single-column \emph{matrix} of simulated returns, with the same
  number of rows as the argument \code{innov}.
}
\description{
Simulate a \emph{Schwartz} process using \emph{Rcpp}.
}
\details{
The function \code{sim_schwartz()} simulates a \emph{Schwartz} process
  using fast \emph{Rcpp} \code{C++} code.
  
  The \emph{Schwartz} process is the exponential of the
  \emph{Ornstein-Uhlenbeck} process, and similar comments apply to it.
  The prices are calculated as the exponentially compounded returns, so they
  are never negative. The log prices can be obtained by taking the logarithm
  of the prices.
  
  The function \code{sim_schwartz()} simulates the percentage returns as
  equal to the difference between the equilibrium price \eqn{\mu} minus the
  latest price \eqn{p_{i-1}}, times the mean reversion parameter
  \eqn{\theta}, plus a random innovation proportional to the volatility
  \eqn{\sigma}.

  The function \code{sim_schwartz()} returns a single-column \emph{matrix}
  representing the \emph{time series} of simulated returns.
}
\examples{
\dontrun{
# Define the Schwartz model parameters
eq_price <- 2.0
sig_ma <- 0.01
the_ta <- 0.01
in_nov <- matrix(rnorm(1e3))
# Simulate Schwartz process using Rcpp
re_turns <- HighFreq::sim_schwartz(eq_price=eq_price, volat=sig_ma, theta=the_ta, innov=in_nov)
plot(exp(cumsum(re_turns)), t="l", main="Simulated Schwartz Prices", ylab="prices")
}

}
