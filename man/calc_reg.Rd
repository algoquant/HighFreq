% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_reg}
\alias{calc_reg}
\title{Perform multivariate regression using different methods, and return a vector
of regression coefficients, their t-values, and the last residual z-score.}
\usage{
calc_reg(respv, predm, controlv)
}
\arguments{
\item{\code{respv}}{A single-column \emph{time series} or a \emph{vector}
of response data.}

\item{\code{predm}}{A \emph{time series} or a \emph{matrix} of predictor
data.}

\item{\code{controlv}}{A \emph{list} of model parameters (see Details).}
}
\value{
A single-row matrix with the regression coefficients, their
  t-values, and the last residual z-score.
}
\description{
Perform multivariate regression using different methods, and return a vector
of regression coefficients, their t-values, and the last residual z-score.
}
\details{
The function \code{calc_reg()} performs multivariate regression using
  different methods, and returns a vector of regression coefficients, their
  t-values, and the last residual z-score.
  
  The function \code{calc_reg()} accepts a list of regression model
  parameters through the argument \code{controlv}.
  The list of model parameters can be created using the function
  \code{param_reg()}.  Below is a description of the model parameters.

  If \code{regmod = "least_squares"} (the default) then it performs the
  standard least squares regression, the same as the function
  \code{calc_lm()}, and the function \code{lm()} from the \code{R} package
  \emph{stats}.
  But it uses \code{RcppArmadillo} \code{C++} code so it's several times
  faster than \code{lm()}.

  If \code{regmod = "regular"} then it performs shrinkage regression.  It
  calculates the \emph{reduced inverse} of the predictor matrix from its
  singular value decomposition.  It performs regularization by selecting
  only the largest \emph{singular values} equal in number to \code{dimax}.
  
  If \code{regmod = "quantile"} then it performs quantile regression (not
  implemented yet).

  The length of the return vector depends on the number of columns of the
  predictor matrix (including the intercept column, if it's been added in
  \code{R}).
  The number of regression coefficients is equal to the number of columns of
  the predictor matrix.
  The length of the return vector is equal to the number of regression
  coefficients, plus their t-values, plus the z-score.
  The number of t-values is equal to the number of coefficients.

  For example, if the number of columns of the predictor matrix is equal to
  \code{n}, then \code{calc_reg()} returns a vector with \code{2n+1}
  elements: \code{n} regression coefficients, \code{n} corresponding
  t-values, and \code{1} z-score value.
}
\examples{
\dontrun{
# Calculate historical returns
retp <- na.omit(rutils::etfenv$returns[, c("XLF", "VTI", "IEF")])
# Response equals XLF returns
respv <- retp[, 1]
# Predictor matrix equals VTI and IEF returns
predm <- retp[, -1]
# Perform multivariate regression using lm()
regmod <- lm(respv ~ predm)
regsum <- summary(regmod)
coeff <- regsum$coefficients
# Create a default list of regression parameters
controlv <- HighFreq::param_reg()
# Add unit intercept column to the predictor matrix
predm <- cbind(rep(1, NROW(predm)), predm)
# Perform multivariate regression using calc_reg()
regarma <- drop(HighFreq::calc_reg(respv=respv, predm=predm, controlv=controlv))
# Compare the outputs of both functions
all.equal(regarma[1:(2*NCOL(predm))], 
  c(coeff[, "Estimate"], coeff[, "t value"]), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::calc_reg(respv=respv, predm=predm, controlv=controlv),
  Rcode=lm(respv ~ predm),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
