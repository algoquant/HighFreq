% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_reg}
\alias{calc_reg}
\title{Perform multivariate regression using different methods, and return a vector
of regression coefficients, their t-values, and the last residual z-score.}
\usage{
calc_reg(respv, predv, controlv)
}
\arguments{
\item{\code{respv}}{A single-column \emph{time series} or a \emph{vector}
of response data.}

\item{\code{predv}}{A \emph{time series} or a \emph{matrix} of predictor
data.}

\item{\code{controlv}}{A \emph{list} of model parameters (see Details).}
}
\value{
A single-row matrix with the regression coefficients, their
  t-values, and the last residual z-score.
}
\description{
Perform multivariate regression using different methods, and return a vector
of regression coefficients, their t-values, and the last residual z-score.
}
\details{
The function \code{calc_reg()} performs multivariate regression using
  different methods, and returns a vector of regression coefficients, their
  t-values, and the last residual z-score.
  
  The function \code{calc_reg()} accepts a list of regression model
  parameters through the argument \code{controlv}.
  The list of model parameters can be created using the function
  \code{param_reg()}.  Below is a description of the model parameters.

  If \code{method = "least_squares"} (the default) then it performs the
  standard least squares regression, the same as the function
  \code{calc_lm()}, and the function \code{lm()} from the \code{R} package
  \emph{stats}.
  But it uses \code{RcppArmadillo} \code{C++} code so it's several times
  faster than \code{lm()}.

  If \code{method = "regular"} then it performs shrinkage regression.  It
  calculates the \emph{regularized inverse} of the predictor matrix from its
  singular value decomposition.  It performs regularization by selecting
  only the largest \emph{singular values} equal in number to \code{dimax}.
  
  If \code{method = "quantile"} then it performs quantile regression (not
  implemented yet).

  If \code{intercept = TRUE} then an extra intercept column (unit column) is
  added to the predictor matrix (the default is \code{intercept = TRUE}).
  
  The length of the return vector depends on the number of columns of the
  predictor matrix (including the intercept column, if it's added).
  The length of the return vector is equal to the number of regression
  coefficients, plus their t-values, plus the z-score.
  The number of regression coefficients is equal to the number of columns of
  the predictor matrix (including the intercept column, if it's
  added).
  The number of t-values is equal to the number of coefficients.

  For example, if the number of columns of the predictor matrix is
  equal to \code{n}, and if \code{intercept = TRUE} (the default), then
  \code{calc_reg()} returns a vector with \code{2n+3} elements: \code{n+1}
  regression coefficients (including the intercept coefficient), \code{n+1}
  corresponding t-values, and \code{1} z-score value.

  If \code{intercept = FALSE}, then \code{calc_reg()} returns a vector with
  \code{2n+1} elements: \code{n} regression coefficients (without the
  intercept coefficient), \code{n} corresponding t-values, and \code{1}
  z-score value.
}
\examples{
\dontrun{
# Calculate historical returns
retsp <- na.omit(rutils::etfenv$returns[, c("XLF", "VTI", "IEF")])
# Response equals XLF returns
respv <- retsp[, 1]
# Predictor matrix equals VTI and IEF returns
predv <- retsp[, -1]
# Perform multivariate regression using lm()
lmod <- lm(respv ~ predv)
lmodsum <- summary(lmod)
coeff <- lmodsum$coefficients
# Create a default list of regression parameters
controlv <- HighFreq::param_reg()
# Perform multivariate regression using calc_reg()
regarma <- drop(HighFreq::calc_reg(respv=respv, predv=predv, controlv=controlv))
# Compare the outputs of both functions
all.equal(regarma[1:(2*(1+NCOL(predv)))], 
  c(coeff[, "Estimate"], coeff[, "t value"]), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::calc_reg(respv=respv, predv=predv, controlv=controlv),
  Rcode=lm(respv ~ predv),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
