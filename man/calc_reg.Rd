% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_reg}
\alias{calc_reg}
\title{Perform multivariate regression using different methods, and return a vector
of regression coefficients, their t-values, and the last residual z-score.}
\usage{
calc_reg(
  response,
  predictor,
  intercept = TRUE,
  method = "least_squares",
  eigen_thresh = 1e-05,
  eigen_max = 0L,
  conf_lev = 0.1,
  alpha = 0
)
}
\arguments{
\item{\code{response}}{A single-column \emph{time series} or a \emph{vector}
of response data.}

\item{\code{predictor}}{A \emph{time series} or a \emph{matrix} of predictor
data.}

\item{\code{intercept}}{A \emph{Boolean} specifying whether an intercept
term should be added to the predictor (the default is \code{intercept =
TRUE}).}

\item{\code{method}}{A \emph{string} specifying the type of the regression
model the default is \code{method = "least_squares"} - see Details).}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small singular values in order to regularize the inverse of the
\code{predictor} matrix (the default is \code{1e-5}).}

\item{\code{eigen_max}}{An \emph{integer} equal to the number of singular
values used for calculating the shrinkage inverse of the \code{predictor}
matrix (the default is \code{0} - equivalent to \code{eigen_max} equal to
the number of columns of \code{predictor}).}

\item{\code{conf_lev}}{The confidence level for calculating the
quantiles (the default is \code{conf_lev = 0.75}).}

\item{\code{alpha}}{The shrinkage intensity between \code{0} and \code{1}.
(the default is \code{0}).}
}
\value{
A single-row matrix with
A vector with the regression coefficients, their t-values, and the
  last residual z-score.
}
\description{
Perform multivariate regression using different methods, and return a vector
of regression coefficients, their t-values, and the last residual z-score.
}
\details{
The function \code{calc_reg()} performs multivariate regression using
  different methods, and returns a vector of regression coefficients, their
  t-values, and the last residual z-score.

  If \code{method = "least_squares"} (the default) then it performs the
  standard least squares regression, the same as the function
  \code{calc_lm()}, and the function \code{lm()} from the \code{R} package
  \emph{stats}.
  But it uses \code{RcppArmadillo} \code{C++} code so it's several times
  faster than \code{lm()}.

  If \code{method = "regular"} then it performs shrinkage regression.  It
  calculates the shrinkage inverse of the \code{predictor} matrix from its
  singular value decomposition.  It applies dimension regularization by
  selecting only the largest singular values equal in number to
  \code{eigen_max}.
  
  If \code{method = "quantile"} then it performs quantile regression (not
  implemented yet).

  If \code{intercept = TRUE} then an extra intercept column (unit column) is
  added to the predictor matrix (the default is \code{intercept = FALSE}).
  
  The length of the return vector depends on the number of columns of the
  \code{predictor} matrix (including the intercept column, if it's added).
  The length of the return vector is equal to the number of regression
  coefficients, plus their t-values, plus the z-score.
  The number of regression coefficients is equal to the number of columns of
  the \code{predictor} matrix (including the intercept column, if it's
  added).
  The number of t-values is equal to the number of coefficients.

  For example, if the number of columns of the \code{predictor} matrix is
  equal to \code{n}, and if \code{intercept = TRUE} (the default), then
  \code{calc_reg()} returns a vector with \code{2n+3} elements: \code{n+1}
  regression coefficients (including the intercept coefficient), \code{n+1}
  corresponding t-values, and \code{1} z-score value.

  If \code{intercept = FALSE}, then \code{calc_reg()} returns a vector with
  \code{2n+1} elements: \code{n} regression coefficients (without the
  intercept coefficient), \code{n} corresponding t-values, and \code{1}
  z-score value.
}
\examples{
\dontrun{
# Calculate historical returns
returns <- na.omit(rutils::etfenv$returns[, c("XLF", "VTI", "IEF")])
# Response equals XLF returns
response <- returns[, 1]
# Predictor matrix equals VTI and IEF returns
predictor <- returns[, -1]
# Perform multivariate regression using lm()
lmod <- lm(response ~ predictor)
lmodsum <- summary(lmod)
coeff <- lmodsum$coefficients
# Perform multivariate regression using calc_reg()
reg_arma <- drop(HighFreq::calc_reg(response=response, predictor=predictor))
# Compare the outputs of both functions
all.equal(reg_arma[1:(2*(1+NCOL(predictor)))], 
  c(coeff[, "Estimate"], coeff[, "t value"]), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::calc_reg(response=response, predictor=predictor),
  Rcode=lm(response ~ predictor),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
