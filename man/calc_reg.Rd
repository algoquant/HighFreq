% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_reg}
\alias{calc_reg}
\title{Perform multivariate regression using different methods, and return a vector
of regression coefficients, t-values, and the last residual z-score.}
\usage{
calc_reg(
  response,
  design,
  method = "least_squares",
  eigen_thresh = 0.001,
  eigen_max = 0L,
  confi_level = 0.1,
  alpha = 0
)
}
\arguments{
\item{\code{response}}{A single-column \emph{time series} or a \emph{vector}
of response data.}

\item{\code{design}}{A \emph{time series} or a \emph{matrix} of design data
(predictor or explanatory data).}

\item{\code{method}}{A \emph{string} specifying the type of regression model
(see Details).  (The default is \code{method = "least_squares"})}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small eigenvalues in order to regularize the matrix inverse.  (The default
is \code{0.001})}

\item{\code{eigen_max}}{An \emph{integer} equal to the number of
eigenvectors used for calculating the regularized inverse of the
covariance \emph{matrix} (the default is the number of columns of
\code{re_turns}).}

\item{\code{confi_level}}{The confidence level for calculating the
quantiles. (the default is \code{confi_level = 0.75}).}

\item{\code{alpha}}{The shrinkage intensity between \code{0} and \code{1}.
(the default is \code{0}).}
}
\value{
A vector of regression coefficients, t-values, and the last
  residual z-score.
  For example, if the design matrix has \code{2} columns of data, then
  \code{calc_reg()} returns a vector with \code{7} elements: \code{3}
  regression coefficients (including the intercept coefficient), \code{3}
  corresponding t-values, and \code{1} z-score.
}
\description{
Perform multivariate regression using different methods, and return a vector
of regression coefficients, t-values, and the last residual z-score.
}
\details{
The function \code{calc_reg()} performs multivariate regression using
  different methods, and returns a vector of regression coefficients, their
  t-values, and the last residual z-score.

  If \code{method = "least_squares"} (the default) then it performs the
  standard least squares regression, the same as the function
  \code{calc_reg()}, and the function \code{lm()} from package \emph{stats}.
  It uses \code{RcppArmadillo} \code{C++} code so it's several times faster
  than \code{lm()}.

  If \code{method = "quantile"} then it performs quantile regression (not
  implemented yet).

  \code{calc_weights()} applies dimension regularization to calculate the
  inverse of the covariance \emph{matrix} of returns from its eigen
  decomposition, using the function \code{arma::eig_sym()}.
  
  In addition, it applies shrinkage to the \emph{vector} of mean column
  returns, by shrinking it to its common mean value.
  The shrinkage intensity \code{alpha} determines the amount of shrinkage 
  that is applied, with \code{alpha = 0} representing no shrinkage (with 
  the estimator of mean returns equal to the means of the columns of 
  \code{re_turns}), and \code{alpha = 1} representing complete shrinkage 
  (with the estimator of mean returns equal to the single mean of all the
  columns of \code{re_turns})
}
\examples{
\dontrun{
# Calculate historical returns
re_turns <- na.omit(rutils::etf_env$re_turns[, c("IEF", "VTI", "XLF")])
# Response equals IEF returns
res_ponse <- re_turns[, 1]
# Design matrix equals VTI and XLF returns
de_sign <- re_turns[, -1]
# Perform multivariate regression using lm()
reg_model <- lm(res_ponse ~ de_sign)
sum_mary <- summary(reg_model)
co_eff <- sum_mary$coefficients
# Perform multivariate regression using calc_reg()
reg_arma <- drop(HighFreq::calc_reg(response=res_ponse, design=de_sign))
# Compare the outputs of both functions
all.equal(reg_arma[1:(2*(1+NCOL(de_sign)))], 
  c(co_eff[, "Estimate"], co_eff[, "t value"]), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::calc_reg(response=res_ponse, design=de_sign),
  Rcode=lm(res_ponse ~ de_sign),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
