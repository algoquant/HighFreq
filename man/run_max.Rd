% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_max}
\alias{run_max}
\title{Calculate the rolling maximum of streaming \emph{time series} data.}
\usage{
run_max(tseries, lambda)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix}.}

\item{\code{lambda}}{A \emph{numeric} decay factor.}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{tseries}.
}
\description{
Calculate the rolling maximum of streaming \emph{time series} data.
}
\details{
The function \code{run_max()} calculates the rolling maximum of streaming
  \emph{time series} data by recursively weighing present and past values
  using the decay factor \eqn{\lambda}.

  It first calculates the rolling mean of streaming data:
  \deqn{
    \mu_t = (1-\lambda) p_t + \lambda \mu_{t-1}
  }
  Where \eqn{\mu_t} is the mean value at time \eqn{t}, and \eqn{p_t} is the
  streaming data.

  It then calculates the rolling maximums of streaming data, \eqn{p^{max}_t}:
  \deqn{
    p^{max}_t = max(p_t, p^{max}_{t-1}) + (1-\lambda) (\mu_{t-1} - p^{max}_{t-1})
  }

  The second term pulls the maximum value down to the mean value, allowing
  it to gradually "forget" the maximum value from the more distant past.

  The value of the decay factor \eqn{\lambda} should be in the range between
  \code{0} and \code{1}.  
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, and the rolling maximum values have a stronger
  dependence on past values.  This is equivalent to a long look-back
  interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, and the rolling maximum values have a
  weaker dependence on past values.  This is equivalent to a short look-back
  interval.

  The above recursive formula is convenient for processing live streaming
  data because it doesn't require maintaining a buffer of past data.

  The function \code{run_max()} returns a \emph{matrix} with the same
  dimensions as the input argument \code{tseries}.
}
\examples{
\dontrun{
# Calculate historical prices
price_s <- zoo::coredata(quantmod::Cl(rutils::etf_env$VTI))
# Calculate the rolling maximums
lamb_da <- 0.9
maxs <- HighFreq::run_max(price_s, lambda=lamb_da)
# Plot dygraph of VTI prices and rolling maximums
da_ta <- cbind(quantmod::Cl(rutils::etf_env$VTI), maxs)
colnames(da_ta) <- c("prices", "max")
col_names <- colnames(da_ta)
dygraphs::dygraph(da_ta, main="VTI Prices and Rolling Maximums") \%>\%
  dySeries(name=col_names[1], label=col_names[1], strokeWidth=2, col="blue") \%>\%
  dySeries(name=col_names[2], label=col_names[2], strokeWidth=2, col="red")
}

}
