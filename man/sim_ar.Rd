% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{sim_ar}
\alias{sim_ar}
\title{Simulate \emph{autoregressive} returns by recursively filtering a
\emph{matrix} of innovations through a \emph{matrix} of
\emph{autoregressive} coefficients.}
\usage{
sim_ar(coeff, innov)
}
\arguments{
\item{\code{innov}}{A single-column \emph{matrix} of innovations.}

\item{\code{coeff}}{A single-column \emph{matrix} of \emph{autoregressive}
coefficients.}
}
\value{
A single-column \emph{matrix} of simulated returns, with the same
  number of rows as the argument \code{innov}.
}
\description{
Simulate \emph{autoregressive} returns by recursively filtering a
\emph{matrix} of innovations through a \emph{matrix} of
\emph{autoregressive} coefficients.
}
\details{
The function \code{sim_ar()} recursively filters the \emph{matrix} of
  innovations \code{innov} through the \emph{matrix} of
  \emph{autoregressive} coefficients \code{coeff}, using fast
  \code{RcppArmadillo} \code{C++} code.

  The function \code{sim_ar()} simulates an \emph{autoregressive} process
  \eqn{AR(n)} of order \eqn{n}:
  \deqn{
    r_i = \varphi_1 r_{i-1} + \varphi_2 r_{i-2} + \ldots + \varphi_n r_{i-n} + \xi_i
  }
  Where \eqn{r_i} is the simulated output time series, \eqn{\varphi_i} are
  the \emph{autoregressive} coefficients, and \eqn{\xi_i} are the standard
  normal \emph{innovations}.

  The order \eqn{n} of the \emph{autoregressive} process \eqn{AR(n)}, is
  equal to the number of rows of the \emph{autoregressive} coefficients
  \code{coeff}.

  The function \code{sim_ar()} performs the same calculation as the standard
  \code{R} function \cr\code{filter(x=innov, filter=coeff,
  method="recursive")}, but it's several times faster.
}
\examples{
\dontrun{
# Define AR coefficients
coeff <- matrix(c(0.1, 0.3, 0.5))
# Calculate matrix of innovations
innov <- matrix(rnorm(1e4, sd=0.01))
# Calculate recursive filter using filter()
innof <- filter(innov, filter=coeff, method="recursive")
# Calculate recursive filter using RcppArmadillo
retp <- HighFreq::sim_ar(coeff, innov)
# Compare the two methods
all.equal(as.numeric(retp), as.numeric(innof))
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::sim_ar(coeff, innov),
  Rcode=filter(innov, filter=coeff, method="recursive"),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
