% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HighFreq.R
\name{roll_apply}
\alias{roll_apply}
\title{Apply an aggregation function over a rolling look-back interval and the end
points of an \emph{OHLC} time series.}
\usage{
roll_apply(x_ts, agg_fun = "run_variance", look_back = 11,
  end_points = (0:NROW(x_ts)), by_columns = FALSE, ...)
}
\arguments{
\item{x_ts}{An \emph{OHLC} time series of prices and trading volumes, in
\emph{xts} format.}

\item{agg_fun}{The name of the aggregation function to be applied over a
rolling look-back interval.}

\item{look_back}{The size of the look-back interval, equal to the number of
rows of data used for applying the aggregation function (including the
current row).}

\item{end_points}{An integer vector of end points.}

\item{by_columns}{\emph{Boolean} argument: should the function
\code{agg_fun()} be applied column-wise (individually), or should it be
applied to all the columns combined? (default is \code{FALSE})}

\item{...}{additional parameters to the agg_fun function.}
}
\value{
An \emph{xts} time series with the same number of rows as the
  argument \code{x_ts}.
}
\description{
Apply an aggregation function over a rolling look-back interval and the end
points of an \emph{OHLC} time series.
}
\details{
The function \code{roll_apply()} applies an aggregation function
  over a rolling look-back interval and the end points of an \emph{OHLC} time
  series.

  Performs similar operations to the functions \code{rollapply()} and
  \code{period.apply()} from package
  \href{https://cran.r-project.org/web/packages/xts/index.html}{xts}, and
  also the function \code{apply.rolling()} from package
  \href{https://cran.r-project.org/web/packages/PerformanceAnalytics/index.html}{PerformanceAnalytics}.
  (The function \code{rollapply()} isn't exported from the package
  \href{https://cran.r-project.org/web/packages/xts/index.html}{xts}.)

  But the function \code{roll_apply()} is faster because it performs less
  type-checking and skips other overhead. Unlike the other functions,
  \code{roll_apply()} doesn't produce any leading \emph{NA} values.

  The function \code{roll_apply()} can be called in two different ways,
  depending on the argument \code{end_points}.
  If the argument \code{end_points} isn't explicitly passed to
  \code{roll_apply()}, then the default value is used, and
  \code{roll_apply()} performs aggregations over overlapping intervals at each
  point in time.
  If the argument \code{end_points} is explicitly passed to
  \code{roll_apply()}, then \code{roll_apply()} performs aggregations over
  intervals spanned by the end_points.  If look_back=2 then the aggregations are
  performed over non-overlapping intervals, otherwise they are performed over
  overlapping intervals.

  The aggregation function \code{agg_fun()} can return either a single value
  or a vector of values. If the aggregation function \code{agg_fun()} returns
  a single value, then \code{roll_apply()} returns an \emph{xts} time series
  with a single column. If the aggregation function \code{agg_fun()} returns
  a vector of values, then \code{roll_apply()} returns an \emph{xts} time
  series with multiple columns equal to the length of the vector returned by
  the aggregation function \code{agg_fun()}.
}
\examples{
# extract a single day of SPY data
oh_lc <- SPY["2012-02-13"]
look_back <- 11
# calculate the rolling sums of oh_lc columns over a rolling interval
agg_regations <- roll_apply(oh_lc, agg_fun=sum, look_back=look_back, by_columns=TRUE)
# apply a vector-valued aggregation function over a rolling interval
agg_function <- function(oh_lc)  c(max(oh_lc[, 2]), min(oh_lc[, 3]))
agg_regations <- roll_apply(oh_lc, agg_fun=agg_function, look_back=look_back)
# define end points at 11-minute intervals (HighFreq::SPY is minutely bars)
end_points <- rutils::end_points(oh_lc, inter_val=look_back)
# calculate the sums of oh_lc columns over end_points using non-overlapping intervals
agg_regations <- roll_apply(oh_lc, agg_fun=sum, look_back=2,
                            end_points=end_points, by_columns=TRUE)
# apply a vector-valued aggregation function over the end_points of oh_lc
# using overlapping intervals
agg_regations <- roll_apply(oh_lc, agg_fun=agg_function,
                            look_back=5, end_points=end_points)
}

