% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HighFreq.R
\name{roll_apply}
\alias{roll_apply}
\title{Apply an aggregation function over a rolling look-back interval and the end
points of an \emph{OHLC} time series, using \code{R} code.}
\usage{
roll_apply(
  xtes,
  agg_fun,
  look_back = 2,
  endpoints = seq_along(xtes),
  by_columns = FALSE,
  out_xts = TRUE,
  ...
)
}
\arguments{
\item{...}{additional parameters to the function \code{agg_fun}.}

\item{\code{xtes}}{An \emph{OHLC} time series of prices and trading volumes, in
\emph{xts} format.}

\item{\code{agg_fun}}{The name of the aggregation function to be applied over a
rolling look-back interval.}

\item{\code{look_back}}{The number of end points in the look-back interval used for
applying the aggregation function (including the current row).}

\item{\code{by_columns}}{\emph{Boolean} argument: should the function
\code{agg_fun()} be applied column-wise (individually), or should it be
applied to all the columns combined? (default is \code{FALSE})}

\item{\code{out_xts}}{\emph{Boolean} argument: should the output be coerced into an
\emph{xts} series? (default is \code{TRUE})}

\item{\code{endpoints}}{An integer vector of end points.}
}
\value{
Either an \emph{xts} time series with the number of rows equal to the
  length of argument \code{endpoints}, or a list the length of argument
  \code{endpoints}.
}
\description{
Apply an aggregation function over a rolling look-back interval and the end
points of an \emph{OHLC} time series, using \code{R} code.
}
\details{
The function \code{roll_apply()} applies an aggregation function 
  over a rolling look-back interval attached at the end points of an
  \emph{OHLC} time series.

  The function \code{roll_apply()} is implemented in \code{R} code.


  \code{HighFreq::roll_apply()} performs similar operations to the functions
  \code{rollapply()} and \code{period.apply()} from package 
  \href{https://cran.r-project.org/web/packages/xts/index.html}{xts}, and 
  also the function \code{apply.rolling()} from package 
  \href{https://cran.r-project.org/web/packages/PerformanceAnalytics/index.html}{PerformanceAnalytics}.
  (The function \code{rollapply()} isn't exported from the package 
  \href{https://cran.r-project.org/web/packages/xts/index.html}{xts}.)

  But \code{HighFreq::roll_apply()} is faster because it performs less 
  type-checking and skips other overhead. Unlike the other functions, 
  \code{roll_apply()} doesn't produce any leading \emph{NA} values.

  The function \code{roll_apply()} can be called in two different ways,
  depending on the argument \code{endpoints}.
  If the argument \code{endpoints} isn't explicitly passed to 
  \code{roll_apply()}, then the default value is used, and 
  \code{roll_apply()} performs aggregations over overlapping intervals at
  each point in time.
  
  If the argument \code{endpoints} is explicitly passed to 
  \code{roll_apply()}, then \code{roll_apply()} performs aggregations over 
  intervals attached at the endpoints.  If look_back=2 then the aggregations
  are performed over non-overlapping intervals, otherwise they are performed
  over overlapping intervals.

  If the argument \code{out_xts} is \code{TRUE} (the default) then the output
  is coerced into an \emph{xts} series, with the number of rows equal to the 
  length of argument \code{endpoints}.  Otherwise a list is returned, with
  the length equal to the length of argument \code{endpoints}.
  
  If \code{out_xts} is \code{TRUE} and the aggregation function 
  \code{agg_fun()} returns a single value, then \code{roll_apply()} returns 
  an \emph{xts} time series with a single column. If \code{out_xts} is
  \code{TRUE} and if \code{agg_fun()} returns a vector of values, then
  \code{roll_apply()} returns an \emph{xts} time series with multiple
  columns, equal to the length of the vector returned by the aggregation
  function \code{agg_fun()}.
}
\examples{
# extract a single day of SPY data
ohlc <- HighFreq::SPY["2012-02-13"]
interval <- 11  # number of data points between end points
look_back <- 4  # number of end points in look-back interval
# Calculate the rolling sums of ohlc columns over a rolling look-back interval
agg_regations <- roll_apply(ohlc, agg_fun=sum, look_back=look_back, by_columns=TRUE)
# Apply a vector-valued aggregation function over a rolling look-back interval
agg_function <- function(ohlc)  c(max(ohlc[, 2]), min(ohlc[, 3]))
agg_regations <- roll_apply(ohlc, agg_fun=agg_function, look_back=look_back)
# Define end points at 11-minute intervals (HighFreq::SPY is minutely bars)
endpoints <- rutils::endpoints(ohlc, interval=interval)
# Calculate the sums of ohlc columns over endpoints using non-overlapping intervals
agg_regations <- roll_apply(ohlc, agg_fun=sum, endpoints=endpoints, by_columns=TRUE)
# Apply a vector-valued aggregation function over the endpoints of ohlc
# using overlapping intervals
agg_regations <- roll_apply(ohlc, agg_fun=agg_function,
                            look_back=5, endpoints=endpoints)
}
