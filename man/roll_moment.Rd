% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_moment}
\alias{roll_moment}
\title{Calculate a \emph{matrix} of moment values over a rolling look-back
interval attached at the end points of a \emph{time series} or a
\emph{matrix}.}
\usage{
roll_moment(
  timeser,
  funame = "calc_mean",
  method = "moment",
  confl = 0.75,
  startp = 0L,
  endd = 0L,
  step = 1L,
  lookb = 1L,
  stub = 0L
)
}
\arguments{
\item{\code{timeser}}{A \emph{time series} or a \emph{matrix} of data.}

\item{\code{funame}}{A \emph{character string} specifying the moment
function (the default is \code{funame = "calc_mean"}).}

\item{\code{method}}{A \emph{character string} specifying the type of the
model for the moment (the default is \code{method = "moment"}).}

\item{\code{confl}}{The confidence level for calculating the quantiles of
returns (the default is \code{confl = 0.75}).}

\item{\code{startp}}{An \emph{integer} vector of start points (the default
is \code{startp = 0}).}

\item{\code{endd}}{An \emph{integer} vector of end points (the default is 
\code{endd = 0}).}

\item{\code{step}}{The number of time periods between the end points (the
default is \code{step = 1}).}

\item{\code{lookb}}{The number of end points in the look-back interval
(the default is \code{lookb = 1}).}

\item{\code{stub}}{An \emph{integer} value equal to the first end point for
calculating the end points (the default is \code{stub = 0}).}
}
\value{
A \emph{matrix} with the same number of columns as the input time
  series \code{timeser}, and the number of rows equal to the number of end
  points.
}
\description{
Calculate a \emph{matrix} of moment values over a rolling look-back
interval attached at the end points of a \emph{time series} or a
\emph{matrix}.
}
\details{
The function \code{roll_moment()} calculates a \emph{matrix} of moment
  values, over rolling look-back intervals attached at the end points of the
  \emph{time series} \code{timeser}.
  
  The function \code{roll_moment()} performs a loop over the end points, and
  at each end point it subsets the time series \code{timeser} over a
  look-back interval equal to \code{lookb} number of end points.
  
  It passes the subset time series to the function specified by the argument
  \code{funame}, which calculates the statistic.
  See the functions \code{calc_*()} for a description of the different
  moments.
  The function name must be one of the following:
  \itemize{
    \item "calc_mean" for the estimator of the mean (location),
    \item "calc_var" for the estimator of the dispersion (variance),
    \item "calc_skew" for the estimator of the skewness,
    \item "calc_kurtosis" for the estimator of the kurtosis.
   }
   (The default is the \code{funame = "calc_mean"}).
  
  If the arguments \code{endd} and \code{startp} are not given then it
  first calculates a vector of end points separated by \code{step} time
  periods. It calculates the end points along the rows of \code{timeser}
  using the function \code{calc_endpoints()}, with the number of time
  periods between the end points equal to \code{step} time periods.

  For example, the rolling variance at \code{25} day end points, with a
  \code{75} day look-back, can be calculated using the parameters
  \code{step = 25} and \code{lookb = 3}.

  The function \code{roll_moment()} calls the function \code{calc_momptr()}
  to calculate a pointer to a moment function from the function name
  \code{funame} (string). The function pointer is used internally in the
  \code{C++} code, but the function \code{calc_momptr()} is not exported to
  \code{R}.
  
  The function \code{roll_moment()} is implemented in \code{RcppArmadillo}
  \code{C++} code, which makes it several times faster than \code{R} code.
}
\examples{
\dontrun{
# Define time series of returns using package rutils
retp <- na.omit(rutils::etfenv$returns$VTI)
# Calculate the rolling variance at 25 day end points, with a 75 day look-back
var_rollfun <- HighFreq::roll_moment(retp, fun="calc_var", step=25, lookb=3)
# Calculate the rolling variance using roll_var()
var_roll <- HighFreq::roll_var(retp, step=25, lookb=3)
# Compare the two methods
all.equal(var_rollfun, var_roll, check.attributes=FALSE)
# Define end points and start points
endd <- HighFreq::calc_endpoints(NROW(retp), step=25)
startp <- HighFreq::calc_startpoints(endd, lookb=3)
# Calculate the rolling variance using RcppArmadillo
var_rollfun <- HighFreq::roll_moment(retp, fun="calc_var", startp=startp, endd=endd)
# Calculate the rolling variance using R code
var_roll <- sapply(1:NROW(endd), function(it) {
  var(retp[startp[it]:endd[it]+1, ])
})  # end sapply
var_roll[1] <- 0
# Compare the two methods
all.equal(drop(var_rollfun), var_roll, check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::roll_moment(retp, fun="calc_var", startp=startp, endd=endd),
  Rcode=sapply(1:NROW(endd), function(it) {
    var(retp[startp[it]:endd[it]+1, ])
  }),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}
}
