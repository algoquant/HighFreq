% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_reg}
\alias{run_reg}
\title{Perform running regressions of streaming \emph{time series} of response and
predictor data, and calculate the alphas, betas, and the residuals.}
\usage{
run_reg(response, predictor, lambda, method = "none")
}
\arguments{
\item{\code{response}}{A single-column \emph{time series} or a single-column
\emph{matrix} of response data.}

\item{\code{predictor}}{A \emph{time series} or a \emph{matrix} of predictor
data.}

\item{\code{lambda}}{A \emph{numeric} decay factor to multiply past
estimates.}

\item{\code{method}}{A \emph{string} specifying the method for scaling the
residuals (see Details) (the default is \code{method = "none"} - no
scaling)}
}
\value{
A \emph{matrix} with the regression alphas, betas, and residuals.
}
\description{
Perform running regressions of streaming \emph{time series} of response and
predictor data, and calculate the alphas, betas, and the residuals.
}
\details{
The function \code{run_reg()} calculates the vectors of \emph{alphas}
  \eqn{\alpha_t}, \emph{betas} \eqn{\beta_t}, and the \emph{residuals}
  \eqn{\epsilon_t} of running regressions, by recursively weighing the
  current estimates with past estimates, using the decay factor
  \eqn{\lambda}:
  \deqn{
    \mu^r_t = (1-\lambda) r^r_t + \lambda \mu^r_{t-1}
  }
  \deqn{
    \mu^p_t = (1-\lambda) r^p_t + \lambda \mu^p_{t-1}
  }
  \deqn{
    \sigma^2_t = (1-\lambda) ({r^p_t}^2 - {\mu^p_t}^2) + \lambda \sigma^2_{t-1}
  }
  \deqn{
    \sigma^{cov}_t = (1-\lambda) (r^r_t - \mu^r_t) (r^p_t - \mu^p_t) + \lambda \sigma^{cov}_{t-1}
  }
  \deqn{
    \beta_t = (1-\lambda) \frac{\sigma^{cov}_t}{\sigma^2_t} + \lambda \beta_{t-1}
  }
  \deqn{
    \epsilon_t = (1-\lambda) (r^r_t - \beta_t r^p_t) + \lambda \epsilon_{t-1}
  }
  Where \eqn{\sigma^{cov}_t} are the covariances between the response and
  predictor data at time \eqn{t};
  \eqn{\sigma^2_t} is the vector of predictor variances,
  and \eqn{r^r_t} and \eqn{r^p_t} are the streaming data of the response
  and predictor data.

  The matrices \eqn{\sigma^2}, \eqn{\sigma^{cov}}, and \eqn{\beta} have the
  same dimensions as the input argument \code{predictor}.

  The above recursive formula is convenient for processing live streaming
  data because it doesn't require maintaining a buffer of past data.
  The formula is equivalent to a convolution with exponentially decaying
  weights, but it's faster to calculate.

  The value of the decay factor \eqn{\lambda} should be in the range between
  \code{0} and \code{1}.
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, and the running \emph{z-score} values have a
  stronger dependence on past values.  This is equivalent to a long
  look-back interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, and the running \emph{z-score} values
  have a weaker dependence on past values.  This is equivalent to a short
  look-back interval.

  The \emph{residuals} may be scaled by their volatilities. The default is
  \code{method = "none"} - no scaling.
  If the argument \code{method = "scale"} then the \emph{residuals}
  \eqn{\epsilon_t} are divided by their volatilities \eqn{\sigma^{\epsilon}}
  without subtracting their means:
  \deqn{
    \epsilon_t = \frac{\epsilon_t}{\sigma^{\epsilon}}
  }
  If the argument \code{method = "standardize"} then the means
  \eqn{\mu_{\epsilon}} are subtracted from the \emph{residuals}, and then
  they are divided by their volatilities \eqn{\sigma^{\epsilon}}:
  \deqn{
    \epsilon_t = \frac{\epsilon_t - \mu_{\epsilon}}{\sigma^{\epsilon}}
  }

  The function \code{run_reg()} returns multiple columns of data. If the
  matrix \code{predictor} has \code{n} columns then \code{run_reg()} returns
  a matrix with \code{n+2} columns.  The first column contains the
  \emph{residuals}, the second the \emph{alphas}, and the last columns
  contain the \emph{betas}.
}
\examples{
\dontrun{
# Calculate historical returns
re_turns <- na.omit(rutils::etf_env$re_turns[, c("XLF", "VTI", "IEF")])
# Response equals XLF returns
res_ponse <- re_turns[, 1]
# Predictor matrix equals VTI and IEF returns
predic_tor <- re_turns[, -1]
# Calculate the running regressions
lamb_da <- 0.9
regs <- HighFreq::run_reg(response=res_ponse, predictor=predic_tor, lambda=lamb_da)
# Plot the running alphas
da_ta <- cbind(cumsum(res_ponse), regs[, 1])
colnames(da_ta) <- c("XLF", "alphas")
col_names <- colnames(da_ta)
dygraphs::dygraph(da_ta, main="Alphas of XLF Versus VTI and IEF") \%>\%
  dyAxis("y", label=col_names[1], independentTicks=TRUE) \%>\%
  dyAxis("y2", label=col_names[2], independentTicks=TRUE) \%>\%
  dySeries(name=col_names[1], axis="y", label=col_names[1], strokeWidth=1, col="blue") \%>\%
  dySeries(name=col_names[2], axis="y2", label=col_names[2], strokeWidth=1, col="red")
}

}
