% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_vecw}
\alias{roll_vecw}
\title{Calculate the rolling weighted sums over a single-column \emph{time series}
or a \emph{vector} using \code{RcppArmadillo}.}
\usage{
roll_vecw(se_ries, weight_s)
}
\arguments{
\item{\code{se_ries}}{A single-column \emph{time series} or a \emph{vector}.}

\item{\code{weight_s}}{A \emph{vector} of weights.}
}
\value{
A column \emph{vector} of the same length as the argument
  \code{se_ries}.
}
\description{
Calculate the rolling weighted sums over a single-column \emph{time series}
or a \emph{vector} using \code{RcppArmadillo}.
}
\details{
The function \code{roll_vecw()} calculates the rolling weighted sums of a
  \emph{vector} over its past values (a convolution with the \emph{vector}
  of weights), using \code{RcppArmadillo}. It performs a similar calculation
  as the standard \code{R} function \code{stats::filter(x=se_ries,
  filter=weight_s, method="convolution", sides=1)}, but it's over \code{6}
  times faster, and it doesn't produce any \code{NA} values.
}
\examples{
\dontrun{
# First example
# Create vector from historical prices
re_turns <- as.numeric(rutils::etf_env$VTI[, 6])
# Create simple weights
weight_s <- c(1, rep(0, 10))
# Calculate rolling weighted sums
weight_ed <- HighFreq::roll_vecw(se_ries=re_turns, weight_s=weight_s)
# Compare with original
all.equal(re_turns, as.numeric(weight_ed))
# Second example
# Create exponentially decaying weights
weight_s <- exp(-0.2*1:11)
weight_s <- weight_s/sum(weight_s)
# Calculate rolling weighted sums
weight_ed <- HighFreq::roll_vecw(se_ries=re_turns, weight_s=weight_s)
# Calculate rolling weighted sums using filter()
filter_ed <- stats::filter(x=re_turns, filter=weight_s, method="convolution", sides=1)
# Compare both methods
all.equal(filter_ed[-(1:11)], weight_ed[-(1:11)], check.attributes=FALSE)
}

}
