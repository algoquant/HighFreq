% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_zscore}
\alias{run_zscore}
\title{Calculate the rolling z-scores of two streaming \emph{time series} of
returns.}
\usage{
run_zscore(tseries, lambda)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix} with two
columns of returns data.}

\item{\code{lambda}}{A \emph{numeric} decay factor.}
}
\value{
A \emph{matrix} with four columns of data: the z-scores, the betas,
  and the variances of the two columns of the argument \code{tseries}.
}
\description{
Calculate the rolling z-scores of two streaming \emph{time series} of
returns.
}
\details{
The function \code{run_zscore()} calculates the rolling z-score of 
  two streaming \emph{time series} of returns by recursively weighing the
  products of their present returns with past z-score estimates, using
  the decay factor \eqn{\lambda}:
  \deqn{
    \beta_t = (1-\lambda) \frac{\sigma^{12}_t}{\sigma^2_{2t}} + \lambda \beta_{t-1}
  }
  \deqn{
    z_t = (1-\lambda) (r^1_t - \beta_t r^2_t) + \lambda z_{t-1}
  }
  Where \eqn{z_t} is the z-score estimate at time \eqn{t},
  \eqn{\sigma^{12}_t} is the covariance, \eqn{\beta_t} is the \emph{beta},
  and \eqn{r^1_t} and \eqn{r^2_t} are the streaming returns data.

  The z-score \eqn{z_t} is equal to the residual of the rolling regression.
  The above formula is approximate because it doesn't subtract the mean
  returns.

  The value of the decay factor \eqn{\lambda} should be in the range between
  \code{0} and \code{1}.
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, and the rolling z-score values have a
  stronger dependence on past values.  This is equivalent to a long
  look-back interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, and the rolling z-score values have
  a weaker dependence on past values.  This is equivalent to a short
  look-back interval.

  The above recursive formula is convenient for processing live streaming
  data because it doesn't require maintaining a buffer of past data.
  The formula is equivalent to a convolution with exponentially decaying
  weights, but it's faster.

  The function \code{run_zscore()} returns four columns of data: the
  z-score and the variances of the two columns of the argument
  \code{tseries}.  This allows calculating the rolling correlation.

  The function \code{run_zscore()} performs the same calculation
  as the standard \code{R} function\cr\code{stats::filter(x=series,
  filter=weight_s, method="convolution", sides=1)}, but it's several
  times faster.
}
\examples{
\dontrun{
# Calculate historical returns
re_turns <- zoo::coredata(na.omit(rutils::etf_env$re_turns[, c("IEF", "VTI")]))
# Calculate the rolling z-scores
lamb_da <- 0.9
zscores <- HighFreq::run_zscore(re_turns, lambda=lamb_da)
# Plot the rolling z-scores
x11(width=6, height=5)
plot(zscores[, 1], t="l")
}

}
