% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{mult_mat}
\alias{mult_mat}
\title{Multiply the rows or columns of a \emph{matrix} times a \emph{vector},
element-wise.}
\usage{
mult_mat(vectorv, matrixv, byrow = TRUE)
}
\arguments{
\item{\code{vector}}{A \emph{numeric} \emph{vector}.}

\item{\code{matrix}}{A \emph{numeric} \emph{matrix}.}

\item{\code{byrow}}{A \emph{Boolean} argument: if \code{TRUE} then multiply
the rows of \code{matrix} by \code{vector}, otherwise multiply the columns
(the default is \code{byrow = TRUE}.)}
}
\value{
A \emph{matrix} equal to the product of the arguments \code{matrix}
  times \code{vector}, with the same dimensions as the argument
  \code{matrix}.
}
\description{
Multiply the rows or columns of a \emph{matrix} times a \emph{vector},
element-wise.
}
\details{
The function \code{mult_mat()} multiplies the rows or columns of a
  \emph{matrix} times a \emph{vector}, element-wise.

  If \code{byrow = TRUE} (the default), then function \code{mult_mat()}
  multiplies the rows of the argument \code{matrix} times the argument
  \code{vector}.
  Otherwise it multiplies the columns of \code{matrix}.

  In \code{R}, \emph{matrix} multiplication is performed by columns.
  Performing multiplication by rows is often required, for example when
  multiplying stock returns by portfolio weights.
  But performing multiplication by rows requires explicit loops in \code{R},
  or it requires \emph{matrix} transpose.  And both are slow.

  The function \code{mult_mat()} uses \code{RcppArmadillo} \code{C++}
  code, so when multiplying large \emph{matrix} columns it's several times
  faster than vectorized \code{R} code, and it's even much faster compared
  to \code{R} when multiplying the \emph{matrix} rows.

  The function \code{mult_mat()} performs loops over the \emph{matrix} rows
  and columns using the \code{Armadillo} operators \code{each_row()} and
  \code{each_col()}, instead of performing explicit \code{for()} loops (both
  methods are equally fast).
}
\examples{
\dontrun{
# Create vector and matrix data
matrixv <- matrix(round(runif(25e4), 2), nc=5e2)
vectorv <- round(runif(5e2), 2)

# Multiply the matrix rows using R
matrixr <- t(vectorv*t(matrixv))
# Multiply the matrix rows using C++
matrixp <- HighFreq::mult_mat(vectorv, matrixv, byrow=TRUE)
all.equal(matrixr, matrixp)
# Compare the speed of Rcpp with R code
library(microbenchmark)
summary(microbenchmark(
    Rcpp=HighFreq::mult_mat(vectorv, matrixv, byrow=TRUE),
    Rcode=t(vectorv*t(matrixv)),
    times=10))[, c(1, 4, 5)]  # end microbenchmark summary
    
# Multiply the matrix columns using R
matrixr <- vectorv*matrixv
# Multiply the matrix columns using C++
matrixp <- HighFreq::mult_mat(vectorv, matrixv, byrow=FALSE)
all.equal(matrixr, matrixp)
# Compare the speed of Rcpp with R code
library(microbenchmark)
summary(microbenchmark(
    Rcpp=HighFreq::mult_mat(vectorv, matrixv, byrow=FALSE),
    Rcode=vectorv*matrixv,
    times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
