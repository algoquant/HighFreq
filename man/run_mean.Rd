% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_mean}
\alias{run_mean}
\title{Calculate the exponential moving average (EMA) of streaming \emph{time
series} data using an online recursive formula.}
\usage{
run_mean(timeser, lambdaf, weightv = 0L)
}
\arguments{
\item{\code{timeser}}{A \emph{time series} or a \emph{matrix}.}

\item{\code{lambdaf}}{A decay factor which multiplies past estimates.}

\item{\code{weightv}}{A single-column \emph{matrix} of weights.}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{timeser}.
}
\description{
Calculate the exponential moving average (EMA) of streaming \emph{time
series} data using an online recursive formula.
}
\details{
The function \code{run_mean()} calculates the exponential moving average
  (EMA) of the streaming \emph{time series} data \eqn{p_t} by recursively
  weighting present and past values using the decay factor \eqn{\lambda}. If
  the \code{weightv} argument is equal to zero, then the function
  \code{run_mean()} simply calculates the exponentially weighted moving
  average value of the streaming \emph{time series} data \eqn{p_t}:
  \deqn{
    \bar{p}_t = \lambda \bar{p}_{t-1} + (1 - \lambda) p_t = (1 - \lambda) \sum_{j=0}^{n} \lambda^j p_{t-j}
  }
  
  Some applications require applying additional weight factors, like for
  example the volume-weighted average price indicator (VWAP).  Then the
  streaming prices can be multiplied by the streaming trading volumes.
  
  If the argument \code{weightv} has the same number of rows as the argument
  \code{timeser}, then the function \code{run_mean()} calculates the
  exponential moving average (EMA) in two steps.
  
  First it calculates the trailing mean weights \eqn{\bar{w}_t}:
  \deqn{
    \bar{w}_t = \lambda \bar{w}_{t-1} + (1 - \lambda) w_t
  }
  
  Second it calculates the trailing mean products \eqn{\bar{w p}_t} of the
  weights \eqn{w_t} and the data \eqn{p_t}:
  \deqn{
    \bar{w p}_t = \lambda \bar{w p}_{t-1} + (1 - \lambda) w_t p_t
  }
  Where \eqn{p_t} is the streaming data, \eqn{w_t} are the streaming
  weights, \eqn{\bar{w}_t} are the trailing mean weights, and \eqn{\bar{w p}_t}
  are the trailing mean products of the data and the weights.
  
  The trailing mean weighted value \eqn{\bar{p}_t} is equal to the ratio of the
  data and weights products, divided by the mean weights:
  \deqn{
    \bar{p}_t = \frac{\bar{w p}_t}{\bar{w}_t}
  }

  The above online recursive formulas are convenient for processing live
  streaming data because they don't require maintaining a buffer of past
  data.
  The formulas are equivalent to a convolution with exponentially decaying
  weights, but they're much faster to calculate.
  Using exponentially decaying weights is more natural than using a sliding
  look-back interval, because it gradually "forgets" about the past data.
  
  The value of the decay factor \eqn{\lambda} must be in the range between
  \code{0} and \code{1}.  
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, and the trailing mean values have a stronger
  dependence on past data.  This is equivalent to a long look-back
  interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, and the trailing mean values have a
  weaker dependence on past data.  This is equivalent to a short look-back
  interval.

  The function \code{run_mean()} performs the same calculation as the
  standard \code{R} function\cr\code{stats::filter(x=series, filter=lambdaf,
  method="recursive")}, but it's several times faster.

  The function \code{run_mean()} returns a \emph{matrix} with the same
  dimensions as the input argument \code{timeser}.
}
\examples{
\dontrun{
# Calculate historical prices
ohlc <- rutils::etfenv$VTI
closep <- quantmod::Cl(ohlc)
# Calculate the trailing means
lambdaf <- 0.9 # Decay factor
meanv <- HighFreq::run_mean(closep, lambdaf=lambdaf)
# Calculate the trailing means using R code
pricef <- (1-lambdaf)*filter(closep, 
  filter=lambdaf, init=as.numeric(closep[1, 1])/(1-lambdaf), 
  method="recursive")
all.equal(drop(meanv), unclass(pricef), check.attributes=FALSE)

# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::run_mean(closep, lambdaf=lambdaf),
  Rcode=filter(closep, filter=lambdaf, init=as.numeric(closep[1, 1])/(1-lambdaf), method="recursive"),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
  
# Calculate weights equal to the trading volumes
weightv <- quantmod::Vo(ohlc)
# Calculate the exponential moving average (EMA)
meanw <- HighFreq::run_mean(closep, lambdaf=lambdaf, weightv=weightv)
# Plot dygraph of the EMA
datav <- xts(cbind(meanv, meanw), zoo::index(ohlc))
colnames(datav) <- c("means trailing", "means weighted")
dygraphs::dygraph(datav, main="Trailing Means") \%>\%
  dyOptions(colors=c("blue", "red"), strokeWidth=2) \%>\%
  dyLegend(show="always", width=300)
}  # end dontrun

}
