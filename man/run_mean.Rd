% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_mean}
\alias{run_mean}
\title{Calculate the rolling mean of streaming \emph{time series} data.}
\usage{
run_mean(tseries, lambda)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix}.}

\item{\code{lambda}}{A \emph{numeric} decay factor.}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{tseries}.
}
\description{
Calculate the rolling mean of streaming \emph{time series} data.
}
\details{
The function \code{run_mean()} calculates the rolling mean of streaming
  \emph{time series} data by recursively weighing present and past values
  using the decay factor \eqn{\lambda}:
  \deqn{
    \mu_t = (1-\lambda) p_t + \lambda \mu_{t-1}
  }
  Where \eqn{\mu_t} is the mean value at time \eqn{t}, and \eqn{p_t} is the
  streaming data.

  The function \code{run_mean()} performs the same calculation
  as the standard \code{R} function \code{stats::filter(x=series,
  filter=weight_s, method="convolution", sides=1)}, but it's several
  times faster.

  The function \code{run_mean()} returns a \emph{matrix} with the same
  dimensions as the input argument \code{tseries}.
}
\examples{
\dontrun{
# Calculate historical prices
price_s <- zoo::coredata(quantmod::Cl(rutils::etf_env$VTI))
# Calculate the rolling means
lamb_da <- 0.9
means <- HighFreq::run_mean(re_turns, lambda=lamb_da)
# Calculate rolling means using R code
filter_ed <- (1-lamb_da)*filter(price_s, filter=lamb_da, init=as.numeric(price_s[1, 1])/(1-lamb_da), method="recursive")
all.equal(means, unclass(filter_ed), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::run_mean(price_s, lambda=lamb_da),
  Rcode=filter(price_s, filter=lamb_da, init=as.numeric(price_s[1, 1])/(1-lamb_da), method="recursive"),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
