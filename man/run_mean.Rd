% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_mean}
\alias{run_mean}
\title{Calculate the trailing weighted means of streaming \emph{time series} data.}
\usage{
run_mean(tseries, lambda, weights)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix}.}

\item{\code{lambda}}{A \emph{numeric} decay factor to multiply past
estimates.}

\item{\code{weights}}{A single-column \emph{matrix} of weights.}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{tseries}.
}
\description{
Calculate the trailing weighted means of streaming \emph{time series} data.
}
\details{
The function \code{run_mean()} calculates the trailing weighted means of
  the streaming \emph{time series} data \eqn{p_t} by recursively weighting
  present and past values using the decay factor \eqn{\lambda}. If the
  \code{weights} argument is equal to zero, then the function
  \code{run_mean()} simply calculates the exponentially weighted moving
  average value of the streaming \emph{time series} data \eqn{p_t}:
  \deqn{
    \bar{p}_t = \lambda \bar{p}_{t-1} + (1-\lambda) p_t = (1-\lambda) \sum_{j=0}^{n} \lambda^j p_{t-j}
  }
  
  Some applications require applying additional weight factors, like for
  example the volume-weighted average price indicator (VWAP).  Then the
  streaming prices are multiplied by the streaming trading volumes.
  
  If the \code{weights} argument is not zero, then the function
  \code{run_mean()} calculates the trailing weighted means in two steps.
  
  First it calculates the trailing mean weights \eqn{\bar{w}_t}:
  \deqn{
    \bar{w}_t = \lambda \bar{w}_{t-1} + (1-\lambda) w_t
  }
  
  Second it calculates the the trailing mean products \eqn{\bar{w p}_t} of the
  weights \eqn{w_t} and the data \eqn{p_t}:
  \deqn{
    \bar{w p}_t = \lambda \bar{w p}_{t-1} + (1-\lambda) w_t p_t
  }
  Where \eqn{p_t} is the streaming data, \eqn{w_t} are the streaming
  weights, \eqn{\bar{w}_t} are the trailing mean weights, and \eqn{\bar{w p}_t}
  are the trailing mean products of the data and the weights.
  
  The trailing mean weighted value \eqn{\bar{p}_t} is equal to the ratio of the
  data and weights products, divided by the mean weights:
  \deqn{
    \bar{p}_t = \frac{\bar{w p}_t}{\bar{w}_t}
  }

  The above recursive formulas are convenient for processing live streaming
  data because they don't require maintaining a buffer of past data.
  The formulas are equivalent to a convolution with exponentially decaying
  weights, but they're much faster to calculate.
  Using exponentially decaying weights is more natural than using a sliding
  look-back interval, because it gradually "forgets" about the past data.
  
  The value of the decay factor \eqn{\lambda} must be in the range between
  \code{0} and \code{1}.  
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, and the trailing mean values have a stronger
  dependence on past values.  This is equivalent to a long look-back
  interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, and the trailing mean values have a
  weaker dependence on past values.  This is equivalent to a short look-back
  interval.

  The function \code{run_mean()} performs the same calculation as the
  standard \code{R} function\cr\code{stats::filter(x=series, filter=lambda,
  method="recursive")}, but it's several times faster.

  The function \code{run_mean()} returns a \emph{matrix} with the same
  dimensions as the input argument \code{tseries}.
}
\examples{
\dontrun{
# Calculate historical prices
ohlc <- rutils::etfenv$VTI
closep <- quantmod::Cl(ohlc)
# Calculate the trailing means
lambda <- 0.95
meanv <- HighFreq::run_mean(closep, lambda=lambda, weights=0)
# Calculate trailing means using R code
filtered <- (1-lambda)*filter(closep, 
  filter=lambda, init=as.numeric(closep[1, 1])/(1-lambda), 
  method="recursive")
all.equal(drop(meanv), unclass(filtered), check.attributes=FALSE)

# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::run_mean(closep, lambda=lambda, weights=0),
  Rcode=filter(closep, filter=lambda, init=as.numeric(closep[1, 1])/(1-lambda), method="recursive"),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
  
# Create weights equal to the trading volumes
weightv <- quantmod::Vo(ohlc)
# Calculate the trailing weighted means
meanw <- HighFreq::run_mean(closep, lambda=lambda, weights=weightv)
# Plot dygraph of the trailing weighted means
datav <- xts(cbind(meanv, meanw), zoo::index(ohlc))
colnames(datav) <- c("means trailing", "means weighted")
dygraphs::dygraph(datav, main="Trailing Means") \%>\%
  dyOptions(colors=c("blue", "red"), strokeWidth=2) \%>\%
  dyLegend(show="always", width=500)
}

}
