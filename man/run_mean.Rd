% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{run_mean}
\alias{run_mean}
\title{Calculate the trailing weighted means of streaming \emph{time series} data.}
\usage{
run_mean(tseries, lambda, weights)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix}.}

\item{\code{lambda}}{A \emph{numeric} decay factor to multiply past
estimates.}

\item{\code{weights}}{A single-column \emph{matrix} of weights.}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{tseries}.
}
\description{
Calculate the trailing weighted means of streaming \emph{time series} data.
}
\details{
The function \code{run_mean()} calculates the trailing weighted means of
  the streaming \emph{time series} data \eqn{p_t} by recursively weighing
  present and past values using the decay factor \eqn{\lambda}. If the
  \code{weights} argument is omitted, then the function \code{run_mean()}
  simply calculates the exponentially weighted moving average value of the
  streaming \emph{time series} data \eqn{p_t}:
  \deqn{
    \mu_t = \lambda \mu_{t-1} + (1-\lambda) p_t = (1-\lambda) \sum_{j=0}^{n} \lambda^j p_{t-j}
  }
  
  Some applications require applying additional weight factors, like for
  example the volume-weighted average price indicator.  The streaming prices
  are multiplied by the streaming trading volumes.
  
  If the \code{weights} argument is included, then the function
  \code{run_mean()} calculates the trailing weighted means in two steps.
  
  First it calculates the trailing mean weights \eqn{\mu^w_t}:
  \deqn{
    \mu^w_t = \lambda \mu^w_{t-1} + (1-\lambda) w_t
  }
  
  Second it calculates the the trailing mean products \eqn{\mu^p_t} of the
  weights \eqn{w_t} and the data \eqn{p_t}:
  \deqn{
    \mu^p_t = \lambda \mu^p_{t-1} + (1-\lambda) w_t p_t
  }
  Where \eqn{p_t} is the streaming data, \eqn{w_t} are the streaming
  weights, \eqn{\mu^w_t} are the trailing mean weights, and \eqn{\mu^p_t}
  are the trailing mean products of the data and the weights.
  
  The trailing mean weighted value \eqn{\mu_t} is equal to the ratio of the
  data and weights products, divided by the mean weights:
  \deqn{
    \mu_t = \frac{\mu^p_t}{\mu^w_t}
  }

  The above recursive formulas are convenient for processing live streaming
  data because they don't require maintaining a buffer of past data.
  The formulas are equivalent to a convolution with exponentially decaying
  weights, but they're faster to calculate.
  
  The value of the decay factor \eqn{\lambda} should be in the range between
  \code{0} and \code{1}.  
  If \eqn{\lambda} is close to \code{1} then the decay is weak and past
  values have a greater weight, and the trailing mean values have a stronger
  dependence on past values.  This is equivalent to a long look-back
  interval.
  If \eqn{\lambda} is much less than \code{1} then the decay is strong and
  past values have a smaller weight, and the trailing mean values have a
  weaker dependence on past values.  This is equivalent to a short look-back
  interval.

  The function \code{run_mean()} performs the same calculation as the
  standard \code{R} function\cr\code{stats::filter(x=series, filter=lambda,
  method="recursive")}, but it's several times faster.

  The function \code{run_mean()} returns a \emph{matrix} with the same
  dimensions as the input argument \code{tseries}.
}
\examples{
\dontrun{
# Calculate historical prices
ohlc <- rutils::etfenv$VTI
closep <- quantmod::Cl(ohlc)
# Calculate the trailing means
lambda <- 0.95
means <- HighFreq::run_mean(closep, lambda=lambda)
# Calculate trailing means using R code
filtered <- (1-lambda)*filter(prices, 
  filter=lambda, init=as.numeric(prices[1, 1])/(1-lambda), 
  method="recursive")
all.equal(drop(means), unclass(filtered), check.attributes=FALSE)

# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::run_mean(prices, lambda=lambda),
  Rcode=filter(prices, filter=lambda, init=as.numeric(prices[1, 1])/(1-lambda), method="recursive"),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
  
# Create weights equal to the trading volumes
weights <- quantmod::Vo(ohlc)
# Calculate the trailing weighted means
meanw <- HighFreq::run_mean(prices, lambda=lambda, weights=weights)
# Plot dygraph of the trailing weighted means
datav <- xts(cbind(means, meanw), zoo::index(ohlc))
colnames(datav) <- c("means trailing", "means weighted")
dygraphs::dygraph(datav, main="Trailing Means") \%>\%
  dyOptions(colors=c("blue", "red"), strokeWidth=1) \%>\%
  dyLegend(show="always", width=500)
}

}
