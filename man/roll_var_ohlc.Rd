% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_var_ohlc}
\alias{roll_var_ohlc}
\title{Calculate a \emph{vector} of variance estimates over a rolling look-back
interval for an \emph{OHLC time series}, using different range estimators
and \code{RcppArmadillo}.}
\usage{
roll_var_ohlc(oh_lc, calc_method = "yang_zhang", in_dex = 0L,
  scal_e = TRUE, look_back = 11L)
}
\arguments{
\item{\code{oh_lc}}{An \emph{OHLC time series} or a \emph{numeric matrix} of
prices.}

\item{\code{calc_method}}{A \emph{character} string representing the range
estimator for calculating the variance.  The estimators include:
\itemize{
  \item "close" close-to-close estimator,
  \item "rogers_satchell" Rogers-Satchell estimator,
  \item "garman_klass" Garman-Klass estimator,
  \item "garman_klass_yz" Garman-Klass with account for close-to-open price jumps,
  \item "yang_zhang" Yang-Zhang estimator,
 }
 (The default is the \emph{"yang_zhang"} estimator.)}

\item{\code{in_dex}}{A \emph{vector} with the time index of the \emph{time
series}.  This is an optional argument. (The default is \code{in_dex=0}.)}

\item{\code{scal_e}}{\emph{Boolean} argument: Should the returns be divided
by the number of seconds in each period? (The default is
\code{scal_e=TRUE}.)}

\item{\code{look_back}}{The length of the look-back interval, equal to the
number of time periods (\code{oh_lc} rows) used for calculating a single
variance estimate.}
}
\value{
A column \emph{vector} of the same length as the number of rows of
  \code{oh_lc}.
}
\description{
Calculate a \emph{vector} of variance estimates over a rolling look-back
interval for an \emph{OHLC time series}, using different range estimators
and \code{RcppArmadillo}.
}
\details{
The function \code{roll_var_ohlc()} performs a loop over the rows
  of \code{oh_lc}, subsets a number of previous (past) rows equal to
  \code{look_back}, and passes them into the function
  \code{calc_var_ohlc()}. It uses an expanding look-back interval in the
  initial warmup period, to calculate the same number of elements as the
  number of rows in the input argument \code{oh_lc}.

  The function \code{roll_var_ohlc()} calculates the variance from all the
  different intra-day and day-over-day returns (defined as the differences
  of \emph{OHLC} prices), using several different variance estimation
  methods.
  
  The default \code{calc_method} is \emph{"yang_zhang"}, which theoretically
  has the lowest standard error among unbiased estimators.
  The methods \emph{"close"}, \emph{"garman_klass_yz"}, and
  \emph{"yang_zhang"} do account for \emph{close-to-open} price jumps, while
  the methods \emph{"garman_klass"} and \emph{"rogers_satchell"} do not
  account for \emph{close-to-open} price jumps.

  The optional argument \code{in_dex} is the time index of the \emph{time
  series} \code{oh_lc}. If the time index is in seconds, then the
  differences of the index are equal to the number of seconds in each time
  period.  If the time index is in days, then the differences are equal to
  the number of days in each time period.
  
  If \code{scal_e} is \code{TRUE} (the default), then the returns are
  divided by the differences of the time index (which scales the variance to
  the units of variance per second squared.) This is useful when calculating
  the variance from minutely bar data, because dividing returns by the
  number of seconds decreases the effect of overnight price jumps. If the
  time index is in days, then the variance is equal to the variance per day
  squared.
  
  The function \code{roll_var_ohlc()} is implemented in \code{RcppArmadillo}
  code, so it's many times faster than the equivalent \code{R} code.
}
\examples{
\dontrun{
# Extract time index of SPY returns
oh_lc <- HighFreq::SPY
in_dex <- c(1, diff(xts::.index(HighFreq::SPY)))
# Calculate the rolling variance of SPY returns, with scaling of the returns
var_rolling <- roll_var_ohlc(oh_lc, 
                              calc_method="yang_zhang", 
                              in_dex=in_dex,
                              scal_e=TRUE, 
                              look_back=21)
}
}
