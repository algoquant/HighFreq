% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_var_ohlc}
\alias{roll_var_ohlc}
\title{Calculate a \emph{vector} of variance estimates over a rolling look-back
interval attached at the end points of a \emph{time series} or a
\emph{matrix} with \emph{OHLC} price data.}
\usage{
roll_var_ohlc(
  oh_lc,
  step = 1L,
  look_back = 1L,
  method = "yang_zhang",
  scale = TRUE,
  in_dex = 0L
)
}
\arguments{
\item{\code{oh_lc}}{A \emph{time series} or a \emph{matrix} with \emph{OHLC}
price data.}

\item{\code{step}}{The number of time periods between the end points.}

\item{\code{look_back}}{The number of end points in the look-back interval.}

\item{\code{method}}{A \emph{character} string representing the range
estimator for calculating the variance.  The estimators include:
\itemize{
  \item "close" close-to-close estimator,
  \item "rogers_satchell" Rogers-Satchell estimator,
  \item "garman_klass" Garman-Klass estimator,
  \item "garman_klass_yz" Garman-Klass with account for close-to-open price jumps,
  \item "yang_zhang" Yang-Zhang estimator,
 }
 (The default is the \emph{"yang_zhang"} estimator.)}

\item{\code{scale}}{\emph{Boolean} argument: Should the returns be divided
by the time index, the number of seconds in each period? (The default is
\code{scale = TRUE}.)}

\item{\code{in_dex}}{A \emph{vector} with the time index of the \emph{time
series}.  This is an optional argument. (The default is \code{in_dex=0}.)}
}
\value{
A column \emph{vector} of variance estimates, with the number of
  rows equal to the number of end points.
}
\description{
Calculate a \emph{vector} of variance estimates over a rolling look-back
interval attached at the end points of a \emph{time series} or a
\emph{matrix} with \emph{OHLC} price data.
}
\details{
The function \code{roll_var_ohlc()} calculates a \emph{vector} of variance
  estimates over a rolling look-back interval attached at the end points of
  the \emph{time series} \code{oh_lc}.
  
  The input \emph{OHLC time series} \code{oh_lc} is assumed to be the log
  prices.

  The end points are calculated along the rows of \code{oh_lc} using the
  function \code{calc_endpoints()}, with the number of time periods between
  the end points equal to \code{step}.
  
  The function \code{roll_var_ohlc()} performs a loop over the end points,
  subsets the previous (past) rows of \code{oh_lc}, and passes them into the
  function \code{calc_var_ohlc()}.

  At each end point, the variance is calculated over a look-back interval
  equal to \code{look_back} number of end points.
  In the initial warmup period, the variance is calculated over an expanding
  look-back interval.
  
  For example, the rolling variance at daily end points with an \code{11}
  day look-back, can be calculated using the parameters \code{step = 1} and
  \code{look_back = 11} (Assuming the \code{oh_lc} data has daily
  frequency.)

  Similarly, the rolling variance at \code{25} day end points with a
  \code{75} day look-back, can be calculated using the parameters
  \code{step = 25} and \code{look_back = 3} (because \code{3*25 = 75}).

  The function \code{roll_var_ohlc()} calculates the variance from all the
  different intra-day and day-over-day returns (defined as the differences
  between \emph{OHLC} prices), using several different variance estimation
  methods.
  
  The default \code{method} is \emph{"yang_zhang"}, which theoretically
  has the lowest standard error among unbiased estimators.
  The methods \emph{"close"}, \emph{"garman_klass_yz"}, and
  \emph{"yang_zhang"} do account for \emph{close-to-open} price jumps, while
  the methods \emph{"garman_klass"} and \emph{"rogers_satchell"} do not
  account for \emph{close-to-open} price jumps.

  If \code{scale} is \code{TRUE} (the default), then the returns are
  divided by the differences of the time index (which scales the variance to
  the units of variance per second squared.) This is useful when calculating
  the variance from minutely bar data, because dividing returns by the
  number of seconds decreases the effect of overnight price jumps. If the
  time index is in days, then the variance is equal to the variance per day
  squared.
  
  The optional argument \code{in_dex} is the time index of the \emph{time
  series} \code{oh_lc}. If the time index is in seconds, then the
  differences of the index are equal to the number of seconds in each time
  period.  If the time index is in days, then the differences are equal to
  the number of days in each time period.
  
  The function \code{roll_var_ohlc()} is implemented in \code{RcppArmadillo}
  \code{C++} code, so it's many times faster than the equivalent \code{R}
  code.
}
\examples{
\dontrun{
# Extract the log OHLC prices of SPY
sp_y <- log(HighFreq::SPY)
# Extract the time index of SPY prices
in_dex <- c(1, diff(xts::.index(sp_y)))
# Rolling variance at minutely end points, with a 21 minute look-back
var_rolling <- HighFreq::roll_var_ohlc(oh_lc, 
                              step=1, look_back=21, 
                              method="yang_zhang", 
                              in_dex=in_dex, scale=TRUE)
# Daily OHLC prices
oh_lc <- rutils::etf_env$VTI
in_dex <- c(1, diff(xts::.index(oh_lc)))
# Rolling variance at 5 day end points, with a 20 day look-back (20=4*5)
var_rolling <- HighFreq::roll_var_ohlc(oh_lc, 
                              step=5, look_back=4, 
                              method="yang_zhang", 
                              in_dex=in_dex, scale=TRUE)
# Same calculation in R
n_rows <- NROW(oh_lc)
lag_close = HighFreq::lag_it(oh_lc[, 4])
end_p <- drop(HighFreq::calc_endpoints(n_rows, 3)) + 1
start_p <- drop(HighFreq::calc_startpoints(end_p, 2))
n_pts <- NROW(end_p)
var_rollingr <- sapply(2:n_pts, function(it) {
  ran_ge <- start_p[it]:end_p[it]
  sub_ohlc = oh_lc[ran_ge, ]
  sub_close = lag_close[ran_ge]
  sub_index = in_dex[ran_ge]
  HighFreq::calc_var_ohlc(sub_ohlc, lag_close=sub_close, scale=TRUE, in_dex=sub_index)
})  # end sapply
var_rollingr <- c(0, var_rollingr)
all.equal(drop(var_rolling), var_rollingr)
}
}
