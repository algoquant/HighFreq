% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_var_ohlc}
\alias{roll_var_ohlc}
\title{Calculate a \emph{vector} of variance estimates over a rolling look-back
interval attached at the end points of a \emph{time series} or a
\emph{matrix} with \emph{OHLC} price data.}
\usage{
roll_var_ohlc(
  ohlc,
  startp = 0L,
  endp = 0L,
  step = 1L,
  look_back = 1L,
  stub = 0L,
  method = "yang_zhang",
  scale = TRUE,
  in_dex = 0L
)
}
\arguments{
\item{\code{ohlc}}{A \emph{time series} or a \emph{matrix} with \emph{OHLC}
price data.}

\item{\code{startp}}{An \emph{integer} vector of start points (the default
is \code{startp = 0}).}

\item{\code{endp}}{An \emph{integer} vector of end points (the default is
\code{endp = 0}).}

\item{\code{step}}{The number of time periods between the end points (the
default is \code{step = 1}).}

\item{\code{look_back}}{The number of end points in the look-back interval
(the default is \code{look_back = 1}).}

\item{\code{stub}}{An \emph{integer} value equal to the first end point for
calculating the end points (the default is \code{stub = 0}).}

\item{\code{method}}{A \emph{character} string representing the price range
estimator for calculating the variance.  The estimators include:
\itemize{
  \item "close" close-to-close estimator,
  \item "rogers_satchell" Rogers-Satchell estimator,
  \item "garman_klass" Garman-Klass estimator,
  \item "garman_klass_yz" Garman-Klass with account for close-to-open price jumps,
  \item "yang_zhang" Yang-Zhang estimator,
 }
 (The default is the \emph{"yang_zhang"} estimator.)}

\item{\code{scale}}{\emph{Boolean} argument: Should the returns be divided
by the time index, the number of seconds in each period?  (The default is
\code{scale = TRUE}.)}

\item{\code{in_dex}}{A \emph{vector} with the time index of the \emph{time
series}.  This is an optional argument (the default is \code{in_dex=0}).}
}
\value{
A column \emph{vector} of variance estimates, with the number of
  rows equal to the number of end points.
}
\description{
Calculate a \emph{vector} of variance estimates over a rolling look-back
interval attached at the end points of a \emph{time series} or a
\emph{matrix} with \emph{OHLC} price data.
}
\details{
The function \code{roll_var_ohlc()} calculates a \emph{vector} of variance
  estimates over a rolling look-back interval attached at the end points of
  the \emph{time series} \code{ohlc}.
  
  The input \emph{OHLC time series} \code{ohlc} is assumed to contain the
  log prices.

  The function \code{roll_var_ohlc()} performs a loop over the end points,
  subsets the previous (past) rows of \code{ohlc}, and passes them into the
  function \code{calc_var_ohlc()}.

  At each end point, the variance is calculated over a look-back interval
  equal to \code{look_back} number of end points.
  In the initial warmup period, the variance is calculated over an expanding
  look-back interval.
  
  If the arguments \code{endp} and \code{startp} are not given then it
  first calculates a vector of end points separated by \code{step} time
  periods. It calculates the end points along the rows of \code{ohlc}
  using the function \code{calc_endpoints()}, with the number of time
  periods between the end points equal to \code{step} time periods.

  For example, the rolling variance at daily end points with an \code{11}
  day look-back, can be calculated using the parameters \code{step = 1} and
  \code{look_back = 1} (Assuming the \code{ohlc} data has daily
  frequency.)

  Similarly, the rolling variance at \code{25} day end points with a
  \code{75} day look-back, can be calculated using the parameters
  \code{step = 25} and \code{look_back = 3} (because \code{3*25 = 75}).

  The function \code{roll_var_ohlc()} calculates the variance from all the
  different intra-day and day-over-day returns (defined as the differences
  between \emph{OHLC} prices), using several different variance estimation
  methods.
  
  The default \code{method} is \emph{"yang_zhang"}, which theoretically
  has the lowest standard error among unbiased estimators.
  The methods \emph{"close"}, \emph{"garman_klass_yz"}, and
  \emph{"yang_zhang"} do account for \emph{close-to-open} price jumps, while
  the methods \emph{"garman_klass"} and \emph{"rogers_satchell"} do not
  account for \emph{close-to-open} price jumps.

  If \code{scale} is \code{TRUE} (the default), then the returns are
  divided by the differences of the time index (which scales the variance to
  the units of variance per second squared.) This is useful when calculating
  the variance from minutely bar data, because dividing returns by the
  number of seconds decreases the effect of overnight price jumps. If the
  time index is in days, then the variance is equal to the variance per day
  squared.
  
  The optional argument \code{in_dex} is the time index of the \emph{time
  series} \code{ohlc}. If the time index is in seconds, then the
  differences of the index are equal to the number of seconds in each time
  period.  If the time index is in days, then the differences are equal to
  the number of days in each time period.
  
  The function \code{roll_var_ohlc()} is implemented in \code{RcppArmadillo}
  \code{C++} code, so it's many times faster than the equivalent \code{R}
  code.
}
\examples{
\dontrun{
# Extract the log OHLC prices of SPY
oh_lc <- log(HighFreq::SPY)
# Extract the time index of SPY prices
in_dex <- c(1, diff(xts::.index(oh_lc)))
# Rolling variance at minutely end points, with a 21 minute look-back
var_rolling <- HighFreq::roll_var_ohlc(oh_lc, 
                              step=1, look_back=21, 
                              method="yang_zhang", 
                              in_dex=in_dex, scale=TRUE)
# Daily OHLC prices
oh_lc <- rutils::etf_env$VTI
in_dex <- c(1, diff(xts::.index(oh_lc)))
# Rolling variance at 5 day end points, with a 20 day look-back (20=4*5)
var_rolling <- HighFreq::roll_var_ohlc(oh_lc, 
                              step=5, look_back=4, 
                              method="yang_zhang", 
                              in_dex=in_dex, scale=TRUE)
# Same calculation in R
n_rows <- NROW(oh_lc)
lag_close = HighFreq::lag_it(oh_lc[, 4])
end_p <- drop(HighFreq::calc_endpoints(n_rows, 3)) + 1
start_p <- drop(HighFreq::calc_startpoints(end_p, 2))
n_pts <- NROW(end_p)
var_rollingr <- sapply(2:n_pts, function(it) {
  ran_ge <- start_p[it]:end_p[it]
  sub_ohlc = oh_lc[ran_ge, ]
  sub_close = lag_close[ran_ge]
  sub_index = in_dex[ran_ge]
  HighFreq::calc_var_ohlc(sub_ohlc, lag_close=sub_close, scale=TRUE, in_dex=sub_index)
})  # end sapply
var_rollingr <- c(0, var_rollingr)
all.equal(drop(var_rolling), var_rollingr)
}
}
