% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_kurtosis}
\alias{calc_kurtosis}
\title{Calculate the kurtosis of the columns of a \emph{time series} or a
\emph{matrix} using \code{RcppArmadillo}.}
\usage{
calc_kurtosis(tseries, method = "moment", confl = 0.75)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix} of data.}

\item{\code{method}}{A \emph{character string} specifying the type of the
kurtosis model (the default is \code{method = "moment"} - see Details).}

\item{\code{confl}}{The confidence level for calculating the quantiles of
returns (the default is \code{confl = 0.75}).}
}
\value{
A single-row matrix with the kurtosis of the columns of
  \code{tseries}.
}
\description{
Calculate the kurtosis of the columns of a \emph{time series} or a
\emph{matrix} using \code{RcppArmadillo}.
}
\details{
The function \code{calc_kurtosis()} calculates the kurtosis of the columns
  of the \emph{matrix} \code{tseries} using \code{RcppArmadillo} \code{C++}
  code.

  If \code{method = "moment"} (the default) then \code{calc_kurtosis()}
  calculates the fourth moment of the data.
  But it doesn't de-mean the columns of \code{tseries} because that requires
  copying the matrix \code{tseries} in memory, so it's time-consuming.

  If \code{method = "quantile"} then it calculates the skewness
  \eqn{\kappa} from the differences between the quantiles of the data as
  follows:
  \deqn{
    \kappa = \frac{q_{\alpha} - q_{1-\alpha}}{q_{0.75} - q_{0.25}}
  }
  Where \eqn{\alpha} is the confidence level for calculating the quantiles.

  If \code{method = "nonparametric"} then it calculates the kurtosis as the
  difference between the mean of the data minus its median, divided by the
  standard deviation.
  
  If the number of rows of \code{tseries} is less than \code{3} then it
  returns zeros.
  
  The code examples below compare the function \code{calc_kurtosis()} with the
  kurtosis calculated using \code{R} code.
}
\examples{
\dontrun{
# Define a single-column time series of returns
retp <- na.omit(rutils::etfenv$returns$VTI)
# Calculate the moment kurtosis
HighFreq::calc_kurtosis(retp)
# Calculate the moment kurtosis in R
calc_kurtr <- function(x) {
  x <- (x-mean(x))
  sum(x^4)/var(x)^2/NROW(x)
}  # end calc_kurtr
all.equal(HighFreq::calc_kurtosis(retp), 
  calc_kurtr(retp), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
library(microbenchmark)
summary(microbenchmark(
  Rcpp=HighFreq::calc_kurtosis(retp),
  Rcode=calc_kurtr(retp),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
# Calculate the quantile kurtosis
HighFreq::calc_kurtosis(retp, method="quantile", confl=0.9)
# Calculate the quantile kurtosis in R
calc_kurtq <- function(x, a=0.9) {
  	quantiles <- quantile(x, c(1-a, 0.25, 0.75, a), type=5)
  	(quantiles[4] - quantiles[1])/(quantiles[3] - quantiles[2])
}  # end calc_kurtq
all.equal(drop(HighFreq::calc_kurtosis(retp, method="quantile", confl=0.9)), 
  calc_kurtq(retp, a=0.9), check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
summary(microbenchmark(
  Rcpp=HighFreq::calc_kurtosis(retp, method="quantile"),
  Rcode=calc_kurtq(retp),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
# Calculate the nonparametric kurtosis
HighFreq::calc_kurtosis(retp, method="nonparametric")
# Compare HighFreq::calc_kurtosis() with R nonparametric kurtosis
all.equal(drop(HighFreq::calc_kurtosis(retp, method="nonparametric")), 
  (mean(retp)-median(retp))/sd(retp), 
  check.attributes=FALSE)
# Compare the speed of RcppArmadillo with R code
summary(microbenchmark(
  Rcpp=HighFreq::calc_kurtosis(retp, method="nonparametric"),
  Rcode=(mean(retp)-median(retp))/sd(retp),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
}

}
