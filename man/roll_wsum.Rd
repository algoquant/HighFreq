% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_wsum}
\alias{roll_wsum}
\title{Calculate the rolling weighted sum over a single-column \emph{time series}
or a \emph{vector} using \code{RcppArmadillo}.}
\usage{
roll_wsum(t_series, weight_s)
}
\arguments{
\item{\code{t_series}}{A single-column \emph{time series} or a \emph{vector}.}

\item{\code{weight_s}}{A \emph{vector} of weights.}
}
\value{
A column \emph{vector} of the same length as the argument
  \code{t_series}.
}
\description{
Calculate the rolling weighted sum over a single-column \emph{time series}
or a \emph{vector} using \code{RcppArmadillo}.
}
\details{
The function \code{roll_wsum()} calculates the rolling weighted sum
  of a \emph{vector} over its past values (a convolution with the
  \emph{vector} of weights), using \code{RcppArmadillo}. It performs a
  similar calculation as the standard \code{R} function
  \code{stats::filter(x=t_series, filter=weight_s, method="convolution",
  sides=1)}, but it's over \code{6} times faster, and it doesn't produce any
  \code{NA} values.
}
\examples{
\dontrun{
# First example
# Create vector from historical prices
re_turns <- as.numeric(rutils::etf_env$VTI[, 6])
# Create simple weights
weight_s <- c(1, rep(0, 10))
# Calculate rolling weighted sum
weight_ed <- HighFreq::roll_wsum(t_series=re_turns, weight_s=weight_s)
# Compare with original
all.equal(re_turns, as.numeric(weight_ed))
# Second example
# Create exponentially decaying weights
weight_s <- exp(-0.2*1:11)
weight_s <- weight_s/sum(weight_s)
# Calculate rolling weighted sum
weight_ed <- HighFreq::roll_wsum(t_series=re_turns, weight_s=weight_s)
# Calculate rolling weighted sum using filter()
filter_ed <- stats::filter(x=re_turns, filter=weight_s, method="convolution", sides=1)
# Compare both methods
all.equal(filter_ed[-(1:11)], weight_ed[-(1:11)], check.attributes=FALSE)
}

}
