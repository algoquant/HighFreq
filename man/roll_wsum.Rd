% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_wsum}
\alias{roll_wsum}
\title{Calculate the rolling weighted sums over a \emph{time series} or a
\emph{matrix} using \emph{Rcpp}.}
\usage{
roll_wsum(tseries, endp = NULL, look_back = 1L, stub = NULL, weightv = NULL)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix}.}

\item{\code{endp}}{An \emph{integer} vector of end points (the default is
\code{endp = NULL}).}

\item{\code{look_back}}{The length of the look-back interval, equal to the
number of data points included in calculating the rolling sum (the default
is \code{look_back = 1}).}

\item{\code{stub}}{An \emph{integer} value equal to the first end point for
calculating the end points (the default is \code{stub = NULL}).}

\item{\code{weightv}}{A single-column \emph{matrix} of weights (the default
is \code{weightv = NULL}).}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{tseries}.
}
\description{
Calculate the rolling weighted sums over a \emph{time series} or a
\emph{matrix} using \emph{Rcpp}.
}
\details{
The function \code{roll_wsum()} calculates the rolling weighted sums over
  the columns of the data \code{tseries}.

  The function \code{roll_wsum()} calculates the rolling weighted sums as
  convolutions of the columns of \code{tseries} with the \emph{column
  vector} of weights using the \code{Armadillo} function
  \code{arma::conv2()}.  It performs a similar calculation to the standard
  \code{R} function \cr\code{stats::filter(x=retsp, filter=weightv,
  method="convolution", sides=1)}, but it can be many times faster, and it
  doesn't produce any leading \code{NA} values.
  
  The function \code{roll_wsum()} returns a \emph{matrix} with the same
  dimensions as the input argument \code{tseries}.

  The arguments \code{weightv}, \code{endp}, and \code{stub} are
  optional.
  
  If the argument \code{weightv} is not supplied, then simple sums are
  calculated, not weighted sums.
  
  If either the \code{stub} or \code{endp} arguments are supplied,
  then the rolling sums are calculated at the end points. 
  
  If only the argument \code{stub} is supplied, then the end points are
  calculated from the \code{stub} and \code{look_back} arguments. The first
  end point is equal to \code{stub} and the end points are spaced
  \code{look_back} periods apart.
  
  If the arguments \code{weightv}, \code{endp}, and \code{stub} are
  not supplied, then the sums are calculated over a number of data points
  equal to \code{look_back}.
  
  The function \code{roll_wsum()} is also several times faster than
  \code{rutils::roll_sum()} which uses vectorized \code{R} code.
  
  Technical note:
  The function \code{roll_wsum()} has arguments with default values equal to
  \code{NULL}, which are implemented in \code{Rcpp} code.
}
\examples{
\dontrun{
# First example
# Calculate historical returns
retsp <- na.omit(rutils::etfenv$returns[, c("VTI", "IEF")])
# Define parameters
look_back <- 22
# Calculate rolling sums and compare with rutils::roll_sum()
sumc <- HighFreq::roll_sum(retsp, look_back)
sumr <- rutils::roll_sum(retsp, look_back)
all.equal(sumc, coredata(sumr), check.attributes=FALSE)
# Calculate rolling sums using R code
sumr <- apply(zoo::coredata(retsp), 2, cumsum)
sumlag <- rbind(matrix(numeric(2*look_back), nc=2), sumr[1:(NROW(sumr) - look_back), ])
sumr <- (sumr - sumlag)
all.equal(sumc, sumr, check.attributes=FALSE)

# Calculate rolling sums at end points
stubv <- 21
sumc <- HighFreq::roll_wsum(retsp, look_back, stub=stubv)
endp <- (stubv + look_back*(0:(NROW(retsp) \%/\% look_back)))
endp <- endp[endp < NROW(retsp)]
sumr <- apply(zoo::coredata(retsp), 2, cumsum)
sumr <- sumr[endp+1, ]
sumlag <- rbind(numeric(2), sumr[1:(NROW(sumr) - 1), ])
sumr <- (sumr - sumlag)
all.equal(sumc, sumr, check.attributes=FALSE)

# Calculate rolling sums at end points - pass in endp
sumc <- HighFreq::roll_wsum(retsp, endp=endp)
all.equal(sumc, sumr, check.attributes=FALSE)

# Create exponentially decaying weights
weightv <- exp(-0.2*(1:11))
weightv <- matrix(weightv/sum(weightv), nc=1)
# Calculate rolling weighted sum
sumc <- HighFreq::roll_wsum(retsp, weightv=weightv)
# Calculate rolling weighted sum using filter()
filtered <- filter(x=retsp, filter=weightv, method="convolution", sides=1)
all.equal(sumc[-(1:11), ], filtered[-(1:11), ], check.attributes=FALSE)

# Calculate rolling weighted sums at end points
sumc <- HighFreq::roll_wsum(retsp, endp=endp, weightv=weightv)
all.equal(sumc, filtered[endp+1, ], check.attributes=FALSE)

# Create simple weights equal to a 1 value plus zeros
weightv <- matrix(c(1, rep(0, 10)), nc=1)
# Calculate rolling weighted sum
weighted <- HighFreq::roll_wsum(retsp, weightv=weightv)
# Compare with original
all.equal(coredata(retsp), weighted, check.attributes=FALSE)
}

}
