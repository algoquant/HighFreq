% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_weights}
\alias{calc_weights}
\title{Calculate the optimal portfolio weights for different objective functions.}
\usage{
calc_weights(re_turns, typ_e = "max_sharpe", to_l = 0.001,
  max_eigen = 0L, pro_b = 0.1, al_pha = 0, scal_e = TRUE,
  vo_l = 0.01)
}
\arguments{
\item{\code{re_turns}}{A \emph{matrix} of excess returns data (the returns
in excess of the risk-free rate).}

\item{\code{typ_e}}{A \emph{string} specifying the objective for calculating
the weights (see Details).}

\item{\code{to_l}}{A \emph{numeric} tolerance level for discarding small
eigenvalues in order to regularize the matrix inverse.  (The default is
\code{0.001})}

\item{\code{max_eigen}}{An \emph{integer} equal to the number of
eigenvectors used for calculating the regularized inverse of the
covariance \emph{matrix} (the default is the number of columns of
\code{re_turns}).}

\item{\code{al_pha}}{The shrinkage intensity between \code{0} and \code{1}.
(the default is \code{0}).}

\item{\code{scal_e}}{A \emph{Boolean} specifying whether the weights should
be scaled (the default is \code{scal_e=TRUE}).}

\item{\code{vo_l}}{A \emph{numeric} volatility target for scaling the
weights.  (The default is \code{0.001})}
}
\value{
A column \emph{vector} of the same length as the number of columns
  of \code{re_turns}.
}
\description{
Calculate the optimal portfolio weights for different objective functions.
}
\details{
The function \code{calc_weights()} calculates the optimal portfolio
  weights for different objective functions, using \code{RcppArmadillo}.

  If \code{typ_e == "max_sharpe"} (the default) then \code{calc_weights()}
  calculates the weights of the maximum Sharpe portfolio, by multiplying the
  inverse of the covariance \emph{matrix} times the mean column returns.
  
  If \code{typ_e == "min_var"} then it calculates the weights of the minimum
  variance portfolio under linear constraints.
  
  If \code{typ_e == "min_varpca"} then it calculates the weights of the
  minimum variance portfolio under quadratic constraints (which is the
  highest order principal component).

  If \code{typ_e == "rank"} then it calculates the weights as the ranks
  (order index) of the trailing Sharpe ratios of the portfolio assets.

  If \code{scal_e == TRUE} (the default) then the weights are scaled so that
  the resulting portfolio has a volatility equal to \code{vo_l}.
  
  \code{calc_weights()} applies dimensional regularization to calculate the
  inverse of the covariance \emph{matrix} of returns from its eigen
  decomposition, using the function \code{arma::eig_sym()}.
  
  In addition, it applies shrinkage to the \emph{vector} of mean column
  returns, by shrinking it to its common mean value.
  The shrinkage intensity \code{al_pha} determines the amount of shrinkage 
  that is applied, with \code{al_pha = 0} representing no shrinkage (with 
  the estimator of mean returns equal to the means of the columns of 
  \code{re_turns}), and \code{al_pha = 1} representing complete shrinkage 
  (with the estimator of mean returns equal to the single mean of all the
  columns of \code{re_turns})
}
\examples{
\dontrun{
# Calculate covariance matrix of ETF returns
re_turns <- na.omit(rutils::etf_env$re_turns[, 1:16])
ei_gen <- eigen(cov(re_turns))
# Calculate regularized inverse of covariance matrix
max_eigen <- 3
eigen_vec <- ei_gen$vectors[, 1:max_eigen]
eigen_val <- ei_gen$values[1:max_eigen]
in_verse <- eigen_vec \%*\% (t(eigen_vec) / eigen_val)
# Define shrinkage intensity and apply shrinkage to the mean returns
al_pha <- 0.5
col_means <- colMeans(re_turns)
col_means <- ((1-al_pha)*col_means + al_pha*mean(col_means))
# Calculate weights using R
weight_s <- in_verse \%*\% col_means
n_col <- NCOL(re_turns)
weights_r <- weights_r*sd(re_turns \%*\% rep(1/n_col, n_col))/sd(re_turns \%*\% weights_r)
# Calculate weights using RcppArmadillo
weight_s <- drop(HighFreq::calc_weights(re_turns, max_eigen=max_eigen, al_pha=al_pha))
all.equal(weight_s, weights_r)
}

}
