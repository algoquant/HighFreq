% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_weights}
\alias{calc_weights}
\title{Calculate the optimal portfolio weights for different types of objective
functions.}
\usage{
calc_weights(
  returns,
  method = "rank_sharpe",
  eigen_thresh = 0.001,
  eigen_max = 0L,
  con_fi = 0.1,
  alpha = 0,
  scale = TRUE,
  vol_target = 0.01
)
}
\arguments{
\item{\code{returns}}{A \emph{time series} or a \emph{matrix} of returns
data (the returns in excess of the risk-free rate).}

\item{\code{method}}{A \emph{string} specifying the objective function for
calculating the weights (see Details) (the default is \code{method =
"rank_sharpe"})}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small eigenvalues in order to regularize the matrix inverse (the default
is \code{0.001})}

\item{\code{eigen_max}}{An \emph{integer} equal to the number of
eigenvectors used for calculating the regularized inverse of the
covariance \emph{matrix} (the default is the number of columns of
\code{returns}).}

\item{\code{con_fi}}{The confidence level for calculating the
quantiles (the default is \code{con_fi = 0.75}).}

\item{\code{alpha}}{The shrinkage intensity between \code{0} and \code{1}.
(the default is \code{0}).}

\item{\code{scale}}{A \emph{Boolean} specifying whether the weights should
be scaled (the default is \code{scale = TRUE}).}

\item{\code{vol_target}}{A \emph{numeric} volatility target for scaling the
weights (the default is \code{0.001})}
}
\value{
A column \emph{vector} of the same length as the number of columns
  of \code{returns}.
}
\description{
Calculate the optimal portfolio weights for different types of objective
functions.
}
\details{
The function \code{calc_weights()} calculates the optimal portfolio
  weights for different types of objective functions, using
  \code{RcppArmadillo} \code{C++} code.

  If \code{method = "rank_sharpe"} (the default) then it calculates the
  weights as the ranks (order index) of the trailing Sharpe ratios of the
  asset \code{returns}.

  If \code{method = "rank"} then it calculates the weights as the ranks
  (order index) of the last row of the \code{returns}.

  If \code{method = "max_sharpe"} then \code{calc_weights()} calculates
  the weights of the maximum Sharpe portfolio, by multiplying the inverse of
  the covariance \emph{matrix} times the mean column returns.

  If \code{method = "min_var"} then it calculates the weights of the
  minimum variance portfolio under linear constraints.

  If \code{method = "min_varpca"} then it calculates the weights of the
  minimum variance portfolio under quadratic constraints (which is the
  highest order principal component).

  If \code{scale = TRUE} (the default) then the weights are scaled so that
  the resulting portfolio has a volatility equal to \code{vol_target}.

  \code{calc_weights()} applies dimension regularization to calculate the
  inverse of the covariance \emph{matrix} of returns from its eigen
  decomposition, using the function \code{arma::eig_sym()}.
  
  In addition, it applies shrinkage to the \emph{vector} of mean column
  returns, by shrinking it to its common mean value.
  The shrinkage intensity \code{alpha} determines the amount of shrinkage 
  that is applied, with \code{alpha = 0} representing no shrinkage (with 
  the estimator of mean returns equal to the means of the columns of 
  \code{returns}), and \code{alpha = 1} representing complete shrinkage 
  (with the estimator of mean returns equal to the single mean of all the
  columns of \code{returns})
}
\examples{
\dontrun{
# Calculate covariance matrix of ETF returns
re_turns <- na.omit(rutils::etf_env$re_turns[, 1:16])
ei_gen <- eigen(cov(re_turns))
# Calculate regularized inverse of covariance matrix
eigen_max <- 3
eigen_vec <- ei_gen$vectors[, 1:eigen_max]
eigen_val <- ei_gen$values[1:eigen_max]
in_verse <- eigen_vec \%*\% (t(eigen_vec) / eigen_val)
# Define shrinkage intensity and apply shrinkage to the mean returns
al_pha <- 0.5
col_means <- colMeans(re_turns)
col_means <- ((1-al_pha)*col_means + al_pha*mean(col_means))
# Calculate weights using R
weight_s <- in_verse \%*\% col_means
n_col <- NCOL(re_turns)
weights_r <- weights_r*sd(re_turns \%*\% rep(1/n_col, n_col))/sd(re_turns \%*\% weights_r)
# Calculate weights using RcppArmadillo
weight_s <- drop(HighFreq::calc_weights(re_turns, eigen_max=eigen_max, alpha=al_pha))
all.equal(weight_s, weights_r)
}

}
