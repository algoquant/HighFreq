% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_weights}
\alias{calc_weights}
\title{Calculate the optimal portfolio weights using a variety of different
objective functions.}
\usage{
calc_weights(
  returns,
  method = "maxsharpe",
  eigen_thresh = 1e-05,
  dimax = 0L,
  confl = 0.1,
  alpha = 0,
  rankw = FALSE,
  centerw = FALSE,
  scalew = "voltarget",
  vol_target = 0.01
)
}
\arguments{
\item{\code{returns}}{A \emph{time series} or a \emph{matrix} of returns
data (the returns in excess of the risk-free rate).}

\item{\code{method}}{A \emph{string} specifying the method for
calculating the weights (see Details) (the default is \code{method =
"sharpem"})}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small singular values in order to regularize the inverse of the
\code{covariance matrix} of \code{returns} (the default is \code{1e-5}).}

\item{\code{dimax}}{An \emph{integer} equal to the number of singular
values used for calculating the regularized inverse of the
\code{covariance matrix} of \code{returns} (the default is \code{0} -
equivalent to \code{dimax} equal to the number of columns of
\code{returns}).}

\item{\code{confl}}{The confidence level for calculating the
quantiles of returns (the default is \code{confl = 0.75}).}

\item{\code{alpha}}{The shrinkage intensity of \code{returns}.
(values between \code{0} and \code{1} - the default is \code{0}).}

\item{\code{rankw}}{A \emph{Boolean} specifying whether the weights should
be ranked (the default is \code{rankw = FALSE}).}

\item{\code{centerw}}{A \emph{Boolean} specifying whether the weights should
be centered (the default is \code{centerw = FALSE}).}

\item{\code{scalew}}{A \emph{string} specifying the method for scaling
the weights (the default is \code{scalew = "voltarget"}).}

\item{\code{vol_target}}{A \emph{numeric} volatility target for scaling the
weights (the default is \code{0.001})}
}
\value{
A column \emph{vector} of the same length as the number of columns
  of \code{returns}.
}
\description{
Calculate the optimal portfolio weights using a variety of different
objective functions.
}
\details{
The function \code{calc_weights()} calculates the optimal portfolio
  weights using a variety of different objective functions.

  If \code{method = "maxsharpe"} (the default) then \code{calc_weights()}
  calculates the weights of the maximum Sharpe portfolio, by multiplying the
  regularized inverse of the \emph{covariance matrix} \eqn{\strong{C}^{-1}}
  times the mean column returns \eqn{\mu}:
  \deqn{
    \strong{w} = \strong{C}^{-1} \mu
  }
  
  If \code{method = "maxsharpemed"} then \code{calc_weights()} uses the
  medians instead of the means.
  
  If \code{method = "minvarlin"} then it calculates the weights of the
  minimum variance portfolio under linear constraint, by multiplying the
  regularized inverse of the \emph{covariance matrix} times the unit vector:
  \deqn{
    \strong{w} = \strong{C}^{-1} \strong{1}
  }
  
  If \code{method = "minvarquad"} then it calculates the weights of the
  minimum variance portfolio under quadratic constraint (which is the
  highest order principal component).

  If \code{method = "sharpem"} then it calculates the momentum weights equal
  to the Sharpe ratios (the \code{returns} divided by their standard
  deviations):
  \deqn{
    \strong{w} = \frac{\mu}{\sigma}
  }

  If \code{method = "kellym"} then it calculates the momentum weights equal
  to the Kelly ratios (the \code{returns} divided by their variance):
  \deqn{
    \strong{w} = \frac{\mu}{\sigma^2}
  }

  \code{calc_weights()} calls the function \code{calc_inv()} to calculate
  the regularized inverse of the \emph{covariance matrix} of \code{returns}.
  It performs regularization by selecting only the largest eigenvalues equal
  in number to \code{dimax}.
  
  In addition, \code{calc_weights()} applies shrinkage to the columns of
  \code{returns}, by shrinking their means to their common mean value:
  \deqn{
    r^{\prime}_i = (1 - \alpha) \, r_i + \alpha \, \bar{r}
  }
  Where \eqn{r_i} is the mean of column \eqn{i} and \eqn{\bar{r}} is the
  mean of all the columns.
  The shrinkage intensity \code{alpha} determines the amount of shrinkage
  that is applied, with \code{alpha = 0} representing no shrinkage (with the
  column means \eqn{r_i} unchanged), and \code{alpha = 1} representing
  complete shrinkage (with the column means all equal to the single mean of
  all the columns: \eqn{r_i = \bar{r}}).

  After the weights are calculated, they are scaled, depending on several
  arguments.

  If \code{rankw = TRUE} then the weights are converted into their ranks.
  The default is \code{rankw = FALSE}.

  If \code{centerw = TRUE} then the weights are centered so that their sum
  is equal to \code{0}.  The default is \code{centerw = FALSE}.

  If \code{scalew = "voltarget"} (the default) then the weights are
  scaled (multiplied by a factor) so that the weighted portfolio has an
  in-sample volatility equal to \code{vol_target}.
  
  If \code{scalew = "voleqw"} then the weights are scaled so that the
  weighted portfolio has the same volatility as the equal weight portfolio.
  
  If \code{scalew = "sumone"} then the weights are scaled so that their
  sum is equal to \code{1}.
  If \code{scalew = "sumsq"} then the weights are scaled so that their
  sum of squares is equal to \code{1}.
  If \code{scalew = "none"} then the weights are not scaled.

  The function \code{calc_weights()} is written in \code{RcppArmadillo}
  \code{C++} code.
}
\examples{
\dontrun{
# Calculate covariance matrix and eigen decomposition of ETF returns
returns <- na.omit(rutils::etfenv$returns[, 1:16])
ncols <- NCOL(returns)
eigend <- eigen(cov(returns))
# Calculate regularized inverse of covariance matrix
dimax <- 3
eigenvec <- eigend$vectors[, 1:dimax]
eigenval <- eigend$values[1:dimax]
invmat <- eigenvec \%*\% (t(eigenvec) / eigenval)
# Define shrinkage intensity and apply shrinkage to the mean returns
alpha <- 0.5
colmeans <- colMeans(returns)
colmeans <- ((1-alpha)*colmeans + alpha*mean(colmeans))
# Calculate weights using R
weightsr <- drop(invmat \%*\% colmeans)
# Apply weights scaling
weightsr <- weightsr*sd(rowMeans(returns))/sd(returns \%*\% weightsr)
weightsr <- 0.01*weightsr/sd(returns \%*\% weightsr)
weightsr <- weightsr/sqrt(sum(weightsr^2))
# Calculate weights using RcppArmadillo
weightcpp <- drop(HighFreq::calc_weights(returns, dimax=dimax, alpha=alpha, scalew="sumsq"))
all.equal(weightcpp, weightsr)
}

}
