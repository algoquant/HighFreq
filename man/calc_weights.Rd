% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_weights}
\alias{calc_weights}
\title{Calculate the optimal portfolio weights using a variety of different
objective functions.}
\usage{
calc_weights(returns, controll)
}
\arguments{
\item{\code{returns}}{A \emph{time series} or a \emph{matrix} of returns
data (the returns in excess of the risk-free rate).}

\item{\code{controll}}{A \emph{list} of portfolio optimization model
parameters (see Details).}
}
\value{
A column \emph{vector} of the same length as the number of columns
  of \code{returns}.
}
\description{
Calculate the optimal portfolio weights using a variety of different
objective functions.
}
\details{
The function \code{calc_weights()} calculates the optimal portfolio
  weights using a variety of different objective functions.

  The function \code{calc_weights()} accepts a list of portfolio
  optimization parameters through the argument \code{controll}.
  The list of portfolio optimization parameters can be created using
  the function \code{param_portf()}.  Below is a description of the
  parameters.

  If \code{method = "maxsharpe"} (the default) then \code{calc_weights()}
  calculates the weights of the maximum Sharpe portfolio, by multiplying the
  \emph{reduced inverse} of the \emph{covariance matrix}
  \eqn{\strong{C}^{-1}} times the mean column returns \eqn{\bar{r}}:
  \deqn{
    \strong{w} = \strong{C}^{-1} \bar{r}
  }
  
  If \code{method = "maxsharpemed"} then \code{calc_weights()} uses the
  medians instead of the means.
  
  If \code{method = "minvarlin"} then it calculates the weights of the
  minimum variance portfolio under linear constraint, by multiplying the
  \emph{reduced inverse} of the \emph{covariance matrix} times the unit
  vector:
  \deqn{
    \strong{w} = \strong{C}^{-1} \strong{1}
  }
  
  If \code{method = "minvarquad"} then it calculates the weights of the
  minimum variance portfolio under quadratic constraint (which is the
  highest order principal component).

  If \code{method = "sharpem"} then it calculates the momentum weights equal
  to the Sharpe ratios (the \code{returns} divided by their standard
  deviations):
  \deqn{
    \strong{w} = \frac{\bar{r}}{\sigma}
  }

  If \code{method = "kellym"} then it calculates the momentum weights equal
  to the Kelly ratios (the \code{returns} divided by their variance):
  \deqn{
    \strong{w} = \frac{\bar{r}}{\sigma^2}
  }

  \code{calc_weights()} calls the function \code{calc_inv()} to calculate
  the \emph{reduced inverse} of the \emph{covariance matrix} of
  \code{returns}. It performs regularization by selecting only the largest
  eigenvalues equal in number to \code{dimax}.
  
  In addition, \code{calc_weights()} applies shrinkage to the columns of
  \code{returns}, by shrinking their means to their common mean value:
  \deqn{
    r^{\prime}_i = (1 - \alpha) \, \bar{r}_i + \alpha \, \mu
  }
  Where \eqn{\bar{r}_i} is the mean of column \eqn{i} and \eqn{\mu} is the
  average of all the column means.
  The shrinkage intensity \code{alpha} determines the amount of shrinkage
  that is applied, with \code{alpha = 0} representing no shrinkage (with the
  column means \eqn{\bar{r}_i} unchanged), and \code{alpha = 1} representing
  complete shrinkage (with the column means all equal to the single mean of
  all the columns: \eqn{\bar{r}_i = \mu}).

  After the weights are calculated, they are scaled, depending on several
  arguments.

  If \code{rankw = TRUE} then the weights are converted into their ranks.
  The default is \code{rankw = FALSE}.

  If \code{centerw = TRUE} then the weights are centered so that their sum
  is equal to \code{0}.  The default is \code{centerw = FALSE}.

  If \code{scalew = "voltarget"} (the default) then the weights are
  scaled (multiplied by a factor) so that the weighted portfolio has an
  in-sample volatility equal to \code{voltarget}.
  
  If \code{scalew = "voleqw"} then the weights are scaled so that the
  weighted portfolio has the same volatility as the equal weight portfolio.
  
  If \code{scalew = "sumone"} then the weights are scaled so that their
  sum is equal to \code{1}.
  
  If \code{scalew = "sumsq"} then the weights are scaled so that their
  sum of squares is equal to \code{1}.
  
  If \code{scalew = "none"} then the weights are not scaled.

  The function \code{calc_weights()} is written in \code{C++}
  \code{RcppArmadillo} code.
}
\examples{
\dontrun{
# Calculate covariance matrix and eigen decomposition of ETF returns
retp <- na.omit(rutils::etfenv$returns[, 1:16])
ncols <- NCOL(retp)
eigend <- eigen(cov(retp))

# Calculate the reduced inverse of covariance matrix
dimax <- 3
eigenvec <- eigend$vectors[, 1:dimax]
eigenval <- eigend$values[1:dimax]
invmat <- eigenvec \%*\% (t(eigenvec) / eigenval)
# Define shrinkage intensity and apply shrinkage to the mean returns
alphac <- 0.5
colmeans <- colMeans(retp)
colmeans <- ((1-alphac)*colmeans + alphac*mean(colmeans))
# Calculate the weights using R
weightr <- drop(invmat \%*\% colmeans)
# Apply weights scaling
weightr <- weightr*sd(rowMeans(retp))/sd(retp \%*\% weightr)
weightr <- 0.01*weightr/sd(retp \%*\% weightr)
weightr <- weightr/sqrt(sum(weightr^2))
# Create a list of portfolio optimization parameters
controll <- HighFreq::param_portf(method="maxsharpe", dimax=dimax, alphac=alphac, scalew="sumsq")
# Calculate the weights using RcppArmadillo
weightcpp <- drop(HighFreq::calc_weights(retp, controll=controll))
all.equal(weightcpp, weightr)

# Calculate the max Sharpe weights and scale them to the target volatility
voltarget <- 0.015
controll <- HighFreq::param_portf(method="maxsharpe", scalew="voltarget", voltarget=voltarget)
weightcpp <- HighFreq::calc_weights(retp, controll=controll)
# The portfolio volatility matches the target volatility
all.equal(sd(retp \%*\% weightcpp), voltarget)

}  # end dontrun

}
