% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{calc_weights}
\alias{calc_weights}
\title{Calculate the optimal portfolio weights for different types of objective
functions.}
\usage{
calc_weights(
  returns,
  method = "rank_sharpe",
  eigen_thresh = 1e-05,
  eigen_max = 0L,
  conf_lev = 0.1,
  alpha = 0,
  scale = TRUE,
  vol_target = 0.01
)
}
\arguments{
\item{\code{returns}}{A \emph{time series} or a \emph{matrix} of returns
data (the returns in excess of the risk-free rate).}

\item{\code{method}}{A \emph{string} specifying the method for
calculating the weights (see Details) (the default is \code{method =
"rank_sharpe"})}

\item{\code{eigen_thresh}}{A \emph{numeric} threshold level for discarding
small singular values in order to regularize the inverse of the
\code{returns} matrix (the default is \code{1e-5}).}

\item{\code{eigen_max}}{An \emph{integer} equal to the number of singular
values used for calculating the shrinkage inverse of the \code{returns}
matrix (the default is \code{0} - equivalent to \code{eigen_max} equal to
the number of columns of \code{returns}).}

\item{\code{conf_lev}}{The confidence level for calculating the
quantiles (the default is \code{conf_lev = 0.75}).}

\item{\code{alpha}}{The shrinkage intensity between \code{0} and \code{1}.
(the default is \code{0}).}

\item{\code{scale}}{A \emph{Boolean} specifying whether the weights should
be scaled (the default is \code{scale = TRUE}).}

\item{\code{vol_target}}{A \emph{numeric} volatility target for scaling the
weights (the default is \code{0.001})}
}
\value{
A column \emph{vector} of the same length as the number of columns
  of \code{returns}.
}
\description{
Calculate the optimal portfolio weights for different types of objective
functions.
}
\details{
The function \code{calc_weights()} calculates the optimal portfolio
  weights for different types of methods, using \code{RcppArmadillo}
  \code{C++} code.

  If \code{method = "rank_sharpe"} (the default) then it calculates the
  weights as the ranks (order index) of the trailing Sharpe ratios of the
  asset \code{returns}.

  If \code{method = "rank"} then it calculates the weights as the ranks
  (order index) of the last row of the \code{returns}.

  If \code{method = "max_sharpe"} then \code{calc_weights()} calculates
  the weights of the maximum Sharpe portfolio, by multiplying the inverse of
  the covariance \emph{matrix} times the mean column returns.

  If \code{method = "min_var"} then it calculates the weights of the
  minimum variance portfolio under linear constraints.

  If \code{method = "min_varpca"} then it calculates the weights of the
  minimum variance portfolio under quadratic constraints (which is the
  highest order principal component).

  If \code{scale = TRUE} (the default) then the weights are scaled so that
  the resulting portfolio has a volatility equal to \code{vol_target}.

  \code{calc_weights()} calculates the shrinkage inverse of the covariance
  \emph{matrix} of \code{returns} from its eigen decomposition.  It applies
  dimension regularization by selecting only the largest eigenvalues equal
  in number to \code{eigen_max}. 
  
  In addition, \code{calc_weights()} applies shrinkage to the columns of
  \code{returns}, by shrinking their means to their common mean value. The
  shrinkage intensity \code{alpha} determines the amount of shrinkage that
  is applied, with \code{alpha = 0} representing no shrinkage (with the
  column means of \code{returns} unchanged), and \code{alpha = 1}
  representing complete shrinkage (with the column means of \code{returns}
  all equal to the single mean of all the columns).
}
\examples{
\dontrun{
# Calculate covariance matrix of ETF returns
returns <- na.omit(rutils::etfenv$returns[, 1:16])
eigend <- eigen(cov(returns))
# Calculate shrinkage inverse of covariance matrix
eigen_max <- 3
eigenvec <- eigend$vectors[, 1:eigen_max]
eigenval <- eigend$values[1:eigen_max]
in_verse <- eigenvec \%*\% (t(eigenvec) / eigenval)
# Define shrinkage intensity and apply shrinkage to the mean returns
al_pha <- 0.5
col_means <- colMeans(returns)
col_means <- ((1-al_pha)*col_means + al_pha*mean(col_means))
# Calculate weights using R
weights <- in_verse \%*\% col_means
n_col <- NCOL(returns)
weights_r <- weights_r*sd(returns \%*\% rep(1/n_col, n_col))/sd(returns \%*\% weights_r)
# Calculate weights using RcppArmadillo
weights <- drop(HighFreq::calc_weights(returns, eigen_max, alpha=al_pha))
all.equal(weights, weights_r)
}

}
