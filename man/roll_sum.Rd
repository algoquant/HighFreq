% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{roll_sum}
\alias{roll_sum}
\title{Calculate the rolling sums over a \emph{time series} or a \emph{matrix}
using \emph{Rcpp}.}
\usage{
roll_sum(tseries, lookb = 1L, weightv = 0L)
}
\arguments{
\item{\code{tseries}}{A \emph{time series} or a \emph{matrix}.}

\item{\code{lookb}}{The length of the look-back interval, equal to the
number of data points included in calculating the rolling sum (the default
is \code{lookb = 1}).}

\item{\code{weightv}}{A single-column \emph{matrix} of weights (the default
is \code{weightv = 0}).}
}
\value{
A \emph{matrix} with the same dimensions as the input argument
  \code{tseries}.
}
\description{
Calculate the rolling sums over a \emph{time series} or a \emph{matrix}
using \emph{Rcpp}.
}
\details{
The function \code{roll_sum()} calculates the rolling \emph{weighted} sums
  over the columns of the data \code{tseries}.
  
  If the argument \code{weightv} is equal to zero (the default), then the
  function \code{roll_sum()} calculates the simple rolling sums of the 
  \emph{time series} data \eqn{p_t} over the look-back interval \eqn{\Delta}:
  \deqn{
    \bar{p}_t = \sum_{j=(t-\Delta+1)}^{t} p_j
  }
  
  If the \code{weightv} argument has the same number of rows as the argument
  \code{tseries}, then the function \code{roll_sum()} calculates rolling 
  \emph{weighted} sums of the \emph{time series} data \eqn{p_t} in two steps.
  
  It first calculates the rolling sums of the products of the weights
  \eqn{w_t} times the \emph{time series} data \eqn{p_t} over the look-back
  interval \eqn{\Delta}:
  \deqn{
    \bar{w}_t = \sum_{j=(t-\Delta+1)}^{t} w_j
  }
  \deqn{
    \bar{p}^w_t = \sum_{j=(t-\Delta+1)}^{t} w_j p_j
  }
  
  It then calculates the rolling \emph{weighted} sums \eqn{\bar{p}_t} as the
  ratio of the sum products of the weights and the data, divided by the sums
  of the weights:
  \deqn{
    \bar{p}_t = \frac{\bar{p}^w_t}{\bar{w}_t}
  }
  
  The function \code{roll_sum()} returns a \emph{matrix} with the same
  dimensions as the input argument \code{tseries}.

  The function \code{roll_sum()} is written in \code{C++} \code{Armadillo}
  code, so it's much faster than equivalent \code{R} code.
}
\examples{
\dontrun{
# Calculate historical returns
retp <- na.omit(rutils::etfenv$returns[, c("VTI", "IEF")])
# Define parameters
lookb <- 11
# Calculate rolling sums and compare with rutils::roll_sum()
sumc <- HighFreq::roll_sum(retp, lookb)
sumr <- rutils::roll_sum(retp, lookb)
all.equal(sumc, coredata(sumr), check.attributes=FALSE)
# Calculate rolling sums using R code
sumr <- apply(zoo::coredata(retp), 2, cumsum)
sumlag <- rbind(matrix(numeric(2*lookb), nc=2), sumr[1:(NROW(sumr) - lookb), ])
sumr <- (sumr - sumlag)
all.equal(sumc, sumr, check.attributes=FALSE)
# Calculate weights equal to the trading volumes
weightv <- quantmod::Vo(rutils::etfenv$VTI)
weightv <- weightv[zoo::index(retp)]
# Calculate rolling weighted sums
sumc <- HighFreq::roll_sum(retp, lookb, 1/weightv)
# Plot dygraph of the weighted sums
datav <- cbind(retp$VTI, sumc[, 1])
colnames(datav) <- c("VTI", "Weighted")
endd <- rutils::calc_endpoints(datav, interval="weeks")
dygraphs::dygraph(cumsum(datav)[endd], main=colnames(datav)) \%>\% 
  dyOptions(colors=c("blue", "red"), strokeWidth=2) \%>\% 
  dyLegend(width=300)
}

}
