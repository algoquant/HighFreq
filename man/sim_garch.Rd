% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{sim_garch}
\alias{sim_garch}
\title{Simulate or estimate the rolling variance under a \emph{GARCH(1,1)} process
using \emph{Rcpp}.}
\usage{
sim_garch(omegac, alphac, betac, innov, is_random = TRUE)
}
\arguments{
\item{\code{omegac}}{Parameter proportional to the long-term average level
of variance.}

\item{\code{alphac}}{The weight associated with recent realized variance
updates.}

\item{\code{betac}}{The weight associated with the past variance estimates.}

\item{\code{innov}}{A single-column \emph{matrix} of innovations.}

\item{\code{is_random}}{\emph{Boolean} argument: Are the innovations random
numbers or historical returns? (The default is \code{is_random = TRUE}.)}
}
\value{
A \emph{matrix} with two columns and with the same number of rows as
  the argument \code{innov}.  The first column are the simulated returns and
  the second column is the variance.
}
\description{
Simulate or estimate the rolling variance under a \emph{GARCH(1,1)} process
using \emph{Rcpp}.
}
\details{
The function \code{sim_garch()} simulates or estimates the rolling variance
  under a \emph{GARCH(1,1)} process using \emph{Rcpp}.

  If \code{is_random = TRUE} (the default) then the innovations \code{innov}
  are treated as random numbers \eqn{\xi_i} and the \emph{GARCH(1,1)}
  process is given by:
  \deqn{
    r_i = \sigma_{i-1} \xi_i
  }
  \deqn{
    \sigma^2_i = \omega + \alpha r^2_i + \beta \sigma_{i-1}^2
  }
  Where \eqn{r_i} and \eqn{\sigma^2_i} are the simulated returns and
  variance, and \eqn{\omega}, \eqn{\alpha}, and \eqn{\beta} are the
  \emph{GARCH} parameters, and \eqn{\xi_i} are standard normal
  \emph{innovations}.

  The long-term equilibrium level of the simulated variance is proportional
  to the parameter \eqn{\omega}:
  \deqn{
    \sigma^2 = \frac{\omega}{1 - \alpha - \beta}
  }
  So the sum of \eqn{\alpha} plus \eqn{\beta} should be less than \eqn{1},
  otherwise the volatility becomes explosive.
  
  If \code{is_random = FALSE} then the function \code{sim_garch()}
  \emph{estimates} the rolling variance from the historical returns. The
  innovations \code{innov} are equal to the historical returns \eqn{r_i} and
  the \emph{GARCH(1,1)} process is simply:
  \deqn{
    \sigma^2_i = \omega + \alpha r^2_i + \beta \sigma_{i-1}^2
  }
  Where \eqn{\sigma^2_i} is the rolling variance.
  
  The above should be viewed as a formula for \emph{estimating} the rolling
  variance from the historical returns, rather than simulating them. It
  represents exponential smoothing of the squared returns with a decay
  factor equal to \eqn{\beta}.

  The function \code{sim_garch()} simulates the \emph{GARCH} process using
  fast \emph{Rcpp} \code{C++} code.
}
\examples{
\dontrun{
# Define the GARCH model parameters
alphac <- 0.79
betac <- 0.2
omegac <- 1e-4*(1-alphac-betac)
# Calculate matrix of standard normal innovations
innov <- matrix(rnorm(1e3))
# Simulate the GARCH process using Rcpp
garch_data <- HighFreq::sim_garch(omegac=omegac, alphac=alphac,  betac=betac, innov=innov)
# Plot the GARCH rolling volatility and cumulative returns
plot(sqrt(garch_data[, 2]), t="l", main="Simulated GARCH Volatility", ylab="volatility")
plot(cumsum(garch_data[, 1]), t="l", main="Simulated GARCH Cumulative Returns", ylab="cumulative returns")
# Calculate historical VTI returns
retp <- na.omit(rutils::etfenv$returns$VTI)
# Estimate the GARCH volatility of VTI returns
garch_data <- HighFreq::sim_garch(omegac=omegac, alphac=alphac,  betac=betac, 
  innov=retp, is_random=FALSE)
# Plot dygraph of the estimated GARCH volatility
dygraphs::dygraph(xts::xts(sqrt(garch_data[, 2]), index(retp)), 
  main="Estimated GARCH Volatility of VTI")
}  # end dontrun

}
