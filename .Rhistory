add=TRUE, lwd=3, col="green")
legend("topright", inset=0.05, bty="n",
leg=c("minutely", "scaled", "normal"),
lwd=6, lty=1, col=c("blue", "red", "green"))
n_rows <- NROW(re_turns)
sapply(list(re_turns=re_turns, rets_scaled=rets_scaled),
function(rets) {sapply(c(skew=3, kurt=4),
function(x) sum((rets/sd(rets))^x)/n_rows)
})  # end sapply
dim(volume_roll)
rets_scaled <- ifelse(vol_ume > 0, sqrt(volume_roll)*re_turns/sqrt(vol_ume), 0)
rets_scaled <- sd(re_turns)*rets_scaled/sd(rets_scaled)
n_rows <- NROW(re_turns)
sapply(list(re_turns=re_turns, rets_scaled=rets_scaled),
function(rets) {sapply(c(skew=3, kurt=4),
function(x) sum((rets/sd(rets))^x)/n_rows)
})  # end sapply
plot(density(re_turns, bw=ma_d/10), xlim=c(-5*ma_d, 5*ma_d),
lwd=3, mgp=c(2, 1, 0), col="blue",
xlab="returns (standardized)", ylab="frequency",
main="Density of Volume-scaled VTI Returns")
lines(density(rets_scaled, bw=ma_d/10), lwd=3, col="red")
curve(expr=dnorm(x, mean=mean(re_turns), sd=sd(re_turns)),
add=TRUE, lwd=3, col="green")
legend("topright", inset=0.05, bty="n",
leg=c("minutely", "scaled", "normal"),
lwd=6, lty=1, col=c("blue", "red", "green"))
?HighFreq::roll_var_ohlc
vari_ance <- HighFreq::roll_var_ohlc(oh_lc, look_back=look_back)
da_ta <- cbind(vari_ance, volume_roll)
class(da_ta)
da_ta <- xts::xts(cbind(vari_ance, volume_roll), index(oh_lc)
col_names <- c("variance", "volume")
colnames(da_ta) <- col_names
da_ta <- xts::xts(cbind(vari_ance, volume_roll), index(oh_lc))
col_names <- c("variance", "volume")
colnames(da_ta) <- col_names
dygraphs::dygraph(da_ta, main="VTI Variance and Trading Volumes") %>%
dyAxis("y", label=col_names[1], independentTicks=TRUE) %>%
dyAxis("y2", label=col_names[2], independentTicks=TRUE) %>%
dySeries(name=col_names[1], axis="y", col="blue") %>%
dySeries(name=col_names[2], axis="y2", col="red")
head(vari_ance)
tail(vari_ance)
vari_ance <- HighFreq::roll_var_ohlc(oh_lc, look_back=look_back, scale=FALSE)
tail(vari_ance)
head(vari_ance)
vari_ance <- HighFreq::roll_var_ohlc(log(oh_lc), look_back=look_back, scale=FALSE)
head(vari_ance)
tail(vari_ance)
head(vari_ance, 22)
head(vari_ance, 44)
head(vari_ance, look_back+3)
vari_ance[1:look_back, ] <- vari_ance[look_back+1, ]
head(vari_ance, look_back+3)
volume_roll <- HighFreq::roll_vec(vol_ume, look_back=look_back)/look_back
da_ta <- xts::xts(cbind(vari_ance, volume_roll), index(oh_lc))
col_names <- c("variance", "volume")
colnames(da_ta) <- col_names
dygraphs::dygraph(da_ta, main="VTI Variance and Trading Volumes") %>%
dyAxis("y", label=col_names[1], independentTicks=TRUE) %>%
dyAxis("y2", label=col_names[2], independentTicks=TRUE) %>%
dySeries(name=col_names[1], axis="y", col="blue") %>%
dySeries(name=col_names[2], axis="y2", col="red")
vari_ance <- HighFreq::roll_var_ohlc(log(oh_lc), method="close", look_back=look_back, scale=FALSE)
vari_ance[1:look_back, ] <- vari_ance[look_back+1, ]
da_ta <- xts::xts(cbind(vari_ance, volume_roll), index(oh_lc))
col_names <- c("variance", "volume")
colnames(da_ta) <- col_names
dygraphs::dygraph(da_ta, main="VTI Variance and Trading Volumes") %>%
dyAxis("y", label=col_names[1], independentTicks=TRUE) %>%
dyAxis("y2", label=col_names[2], independentTicks=TRUE) %>%
dySeries(name=col_names[1], axis="y", col="blue") %>%
dySeries(name=col_names[2], axis="y2", col="red")
dygraphs::dygraph(da_ta, main="VTI Variance and Trading Volumes") %>%
dyAxis("y", label=col_names[1], independentTicks=TRUE) %>%
dyAxis("y2", label=col_names[2], independentTicks=TRUE) %>%
dySeries(name=col_names[1], strokeWidth=2, axis="y", col="blue") %>%
dySeries(name=col_names[2], strokeWidth=2, axis="y2", col="red")
rets_scaled <- ifelse(vol_ume > 0, sqrt(volume_roll)*re_turns/sqrt(vol_ume), 0)
rets_scaled <- sd(re_turns)*rets_scaled/sd(rets_scaled)
n_rows <- NROW(re_turns)
sapply(list(re_turns=re_turns, rets_scaled=rets_scaled),
function(rets) {sapply(c(skew=3, kurt=4),
function(x) sum((rets/sd(rets))^x)/n_rows)
})  # end sapply
ma_d <- mad(re_turns)
plot(density(re_turns, bw=ma_d/10), xlim=c(-5*ma_d, 5*ma_d),
lwd=3, mgp=c(2, 1, 0), col="blue",
xlab="returns (standardized)", ylab="frequency",
main="Density of Volume-scaled VTI Returns")
lines(density(rets_scaled, bw=ma_d/10), lwd=3, col="red")
curve(expr=dnorm(x, mean=mean(re_turns), sd=sd(re_turns)),
add=TRUE, lwd=3, col="green")
# Add legend
legend("topright", inset=0.05, bty="n",
leg=c("minutely", "scaled", "normal"),
lwd=6, lty=1, col=c("blue", "red", "green"))
quartz.save("figure/vti_scaled.png", type="png", width=6, height=5)
plot(density(re_turns, bw=ma_d/10), xlim=c(-5*ma_d, 5*ma_d),
lwd=3, mgp=c(2, 1, 0), col="blue",
xlab="returns (standardized)", ylab="frequency",
main="Density of Volume-scaled VTI Returns")
lines(density(rets_scaled, bw=ma_d/10), lwd=3, col="red")
curve(expr=dnorm(x, mean=mean(re_turns), sd=sd(re_turns)),
add=TRUE, lwd=3, col="green")
# Add legend
legend("topright", inset=0.05, bty="n",
leg=c("unscaled", "scaled", "normal"),
lwd=6, lty=1, col=c("blue", "red", "green"))
quartz.save("figure/vti_scaled.png", type="png", width=6, height=5)
knitr::knit2pdf("/Users/jerzy/Develop/lecture_slides/risk_models.Rnw", bib_engine="biber")
knitr::knit2pdf("/Users/jerzy/Develop/lecture_slides/FRE7241_Lecture_1.Rnw", bib_engine="biber")
knitr::knit2pdf("/Users/jerzy/Develop/lecture_slides/FRE7241_Lecture_1.Rnw", bib_engine="biber")
knitr::purl("/Users/jerzy/Develop/lecture_slides/FRE7241_Lecture_1.Rnw", documentation=0, quiet=TRUE)
install.packages("Rfast")
knitr::knit2pdf("/Users/jerzy/Develop/lecture_slides/FRE7241_Lecture_1.Rnw", bib_engine="biber")
knitr::purl("/Users/jerzy/Develop/lecture_slides/FRE7241_Lecture_1.Rnw", documentation=0, quiet=TRUE)
sessionInfo()
rm(list = ls())
library(rutils)  # Load package rutils
sym_bols <- c("VTI", "VEU", "IEF", "VNQ")
sym_bols
ls()
ls(rutils::etf_env)
price_s <- mget(sym_bols, envir=rutils::etf_env)
ls()
class(price_s)
class(price_s[[1]])
names(price_s)
NROW(price_s)
tail(price_s[[1]])
head(price_s[[1]])
head(price_s[1])
head(price_s[[1]])
head(price_s[[4]])
price_s <- lapply(price_s, quantmod::Cl)
class(price_s)
head(price_s[[1]])
xts_1 <- cbind(price_s[[1]], price_s[[2]], price_s[[3]], price_s[[4]])
class(xts_1)
dim(xts_1)
head(xts_1)
tail(xts_1)
price_s <- do.call(cbind, price_s)
all.equal(xts_1, price_s)
price_s <- do.call(cbind, lapply(
mget(sym_bols, envir=rutils::etf_env), quantmod::Cl))
all.equal(xts_1, price_s)
head(price_s)
sapply(price_s, mean)
sapply(price_s, mean, na.omit=TRUE)
colnames(price_s)
strsplit(colnames(price_s[, 1:4]), split="[.]")
do.call(rbind, strsplit(colnames(price_s[, 1:4]), split="[.]"))
do.call(rbind, strsplit(colnames(price_s[, 1:4]), split="[.]"))[, 1]
colnames(price_s) <- do.call(rbind, strsplit(colnames(price_s), split="[.]"))[, 1]
colnames(price_s)
tail(price_s, 3)
ls()
my_env <- rutils::etf_env
ls(my_env)
rm(capm_stats, envir = my_env)
ls(my_env)
assign("myprices", price_s, envir=my_env)
ls(my_env)
my_env$myprices2 <- price_s
ls(my_env)
all.equal(my_env$myprices, my_env$myprices2)
rm(my_env$myprices2, envir = my_env)
rm(myprices2, envir = my_env)
ls(my_env)
search()
library(microbenchmark)
vec_tor <- runif(1e6)
tail(vec_tor)
NROW(vec_tor)
all.equal(sqrt(vec_tor), vec_tor^0.5)
microbenchmark(
power = vec_tor^0.5,
sqrt = sqrt(vec_tor),
times=10)
24.7/6.2
microbenchmark(
powers = vec_tor^0.5,
sqrt = sqrt(vec_tor),
times=10)
mat_rix <- matrix(rnorm(10000), ncol=2)
dim(mat_rix)
row_sums <- numeric(NROW(mat_rix))
tail(row_sums)
summary(microbenchmark(
row_sums = rowSums(mat_rix),  # end row_sums
ap_ply = apply(mat_rix, 1, sum),  # end apply
l_apply = lapply(1:NROW(mat_rix), function(in_dex)
sum(mat_rix[in_dex, ])),  # end lapply
v_apply = vapply(1:NROW(mat_rix), function(in_dex)
sum(mat_rix[in_dex, ]),
FUN.VALUE = c(sum=0)),  # end vapply
s_apply = sapply(1:NROW(mat_rix), function(in_dex)
sum(mat_rix[in_dex, ])),  # end sapply
for_loop = for (i in 1:NROW(mat_rix)) {
row_sums[i] <- sum(mat_rix[i,])
},  # end for
times=10))[, c(1, 4, 5)]  # end microbenchmark summary
7265.7/51.6
all.equal(rowSums(mat_rix), apply(mat_rix, 1, sum))
rowSums
vector1 <- sin(0.25*pi*1:20)
vector2 <- cos(0.25*pi*1:20)
vector1
vector2
vector1 > vector2
vector3 <- ifelse(vector1 > vector2, vector1, vector2)
vector3 >= vector2
vector3 >= vector1
vector3
vector3 <- cbind(vector1, vector2, vector3)
colnames(vector3)[3] <- "Max"
zoo::plot.zoo(vector3, lwd=2, ylim=c(-1, 1),
xlab="", col=c("green", "blue", "red"),
main="ifelse() Calculates The Max of Two Data Sets")
paws <- function(x, sleep_time=0.01) {
Sys.sleep(sleep_time)
x
}  # end paws
paws(11)
paws(11, sleep_time = 3)
n_cores <- detectCores() - 1
library(parallel)  # Load package parallel
n_cores <- detectCores() - 1
n_cores
paw_s <- mclapply(1:10, paws, mc.cores=n_cores)
summary(microbenchmark(
standard = lapply(1:10, paws),
parallel = mclapply(1:10, paws, mc.cores=n_cores),
times=10)
)[, c(1, 4, 5)]
summary(microbenchmark(
standard = lapply(1:10, paws, sleep_time = 3),
parallel = mclapply(1:10, paws, mc.cores=n_cores, sleep_time = 3),
times=10)
)[, c(1, 4, 5)]
summary(microbenchmark(
standard = lapply(1:10, paws, sleep_time = 0.5),
parallel = mclapply(1:10, paws, mc.cores=n_cores, sleep_time = 0.5),
times=10)
)[, c(1, 4, 5)]
set.seed(1121)  # Reset random number generator
bar_rier <- 20  # Barrier level
n_rows <- 1000  # Number of simulation steps
n_rows
rnorm(11)
set.seed(1121)  # Reset random number generator
pa_th <- cumsum(rnorm(n_rows))
NROW(pa_th)
tail(pa_th)
head(pa_th)
cro_ss <- which(pa_th > bar_rier)
cro_ss
if (NROW(cro_ss)>0) {
pa_th[(cro_ss[1]+1):n_rows] <- pa_th[cro_ss[1]]
}  # end if
plot(pa_th, type="l", col="black",
lty="solid", lwd=2, xlab="", ylab="")
abline(h=bar_rier, lwd=3, col="red")
title(main="Brownian Motion Crossing a Barrier Level", line=0.5)
par(mar=c(3, 3, 2, 1), oma=c(1, 1, 1, 1))
plot(pa_th, type="l", col="black",
lty="solid", lwd=2, xlab="", ylab="")
abline(h=bar_rier, lwd=3, col="red")
title(main="Brownian Motion Crossing a Barrier Level", line=0.5)
sig_ma <- 1.0  # Volatility
dri_ft <- 0.0  # Drift
n_rows <- 1000  # Number of simulation steps
n_simu <- 100  # Number of simulations
set.seed(1121)
n_simu*n_rows
sig_ma
path_s <- rnorm(n_simu*n_rows, mean=dri_ft, sd=sig_ma)
class(path_s)
n_simu
path_s <- matrix(path_s, nc=n_simu)
class(path_s)
dim(path_s)
path_s <- matrixStats::colCumsums(path_s)
# Final distribution of paths
mean(path_s[n_rows, ]) ; sd(path_s[n_rows, ])
n_rows
path_s[n_rows, ]
mean(path_s[n_rows, ])
sd(path_s[n_rows, ])
sqrt(1000)
strik_e <- 50  # Strike price
strik_e
(path_s[n_rows, ] - strik_e)
pay_outs <- (path_s[n_rows, ] - strik_e)
pay_outs > 0
pay_outs[pay_outs > 0]
sum(pay_outs[pay_outs > 0])/n_simu
bar_rier <- 50
cross_ed <- colSums(path_s > bar_rier) > 0
sum(cross_ed)/n_simu
par(mar=c(4, 3, 2, 2), oma=c(0, 0, 0, 0), mgp=c(2.5, 1, 0))
or_der <- order(path_s[n_rows, ])
in_dex <- or_der[seq(1, 100, 9)]
zoo::plot.zoo(path_s[, in_dex], main="Paths of Brownian Motion",
xlab="time steps", ylab=NA, plot.type="single")
abline(h=strik_e, col="red", lwd=3)
text(x=(n_rows-60), y=strik_e, labels="strike price", pos=3, cex=1)
set.seed(1121)  # Reset random number generator
n_rows <- 1000
da_ta <- rnorm(n_rows)
mean(da_ta)
sd(da_ta)
pnorm(1)
sum(da_ta < 1)/n_rows
conf_level <- 0.98
qnorm(conf_level)  # Exact value
cut_off <- conf_level*n_rows
cut_off
da_ta <- sort(da_ta)
da_ta[cut_off]  # Naive Monte Carlo value
n_rows
mean(da_ta); sd(da_ta)
n_boot <- 10000
boot_data <- sapply(1:n_boot, function(x) {
# Sample from Standard Normal Distribution
sampl_e <- rnorm(n_rows)
c(mean=mean(sampl_e), median=median(sampl_e))
})  # end sapply
boot_data[, 1:3]
dim(boot_data)
boot_data <- t(boot_data)
dim(boot_data)
sd(da_ta)/sqrt(n_rows)
sd(da_ta)
sqrt(n_rows)
sd(boot_data[, "mean"])
sd(boot_data[, "median"])
re_turns <- rutils::etf_env$re_turns$VTI
re_turns <- na.omit(re_turns)
n_rows <- NROW(re_turns)
tail(re_turns)
class(re_turns)
n_rows
sampl_e <- re_turns[sample.int(n_rows, replace=TRUE)]
class(sampl_e)
tail(sampl_e)
c(sd=sd(sampl_e), mad=mad(sampl_e))
n_cores
clusterSetRNGStream(clus_ter, 1121)  # Reset random number generator in all cores
n_boot <- 10000
boot_data <- mclapply(1:n_boot, function(x) {
sampl_e <- re_turns[sample.int(n_rows, replace=TRUE)]
c(sd=sd(sampl_e), mad=mad(sampl_e))
}, mc.cores=n_cores)  # end mclapply
class(boot_data)
boot_data <- rutils::do_call(rbind, boot_data)
class(boot_data)
dim(boot_data)
std_errors <- apply(boot_data, MARGIN=2,
function(x) c(mean=mean(x), std_error=sd(x)))
std_errors
0.000323/0.000163
std_errors[2, ]/std_errors[1, ]
0.0262/0.0216
set.seed(1121)
predic_tor <- rnorm(100, mean=2)
noise <- rnorm(100)
res_ponse <- (-3 + predic_tor + noise)
de_sign <- cbind(res_ponse, predic_tor)
dim(de_sign)
tail(de_sign)
be_ta <- cov(de_sign[, 1], de_sign[, 2])/var(de_sign[, 2])
al_pha <- mean(de_sign[, 1]) - be_ta*mean(de_sign[, 2])
plot(res_ponse ~ predic_tor, data=de_sign)
abline(a=al_pha, b=be_ta, lwd=3, col="blue")
n_boot <- 100
boot_data <- sapply(1:n_boot, function(x) {
sampl_e <- sample.int(NROW(de_sign), replace=TRUE)
de_sign <- de_sign[sampl_e, ]
cov(de_sign[, 1], de_sign[, 2])/var(de_sign[, 2])
})  # end sapply
c(mean=mean(boot_data), std_error=sd(boot_data))
be_ta
plot(density(boot_data), lwd=2, xlab="Regression slopes",
main="Bootstrapped Regression Slopes")
abline(v=mean(boot_data), lwd=2, col="red")
text(x=mean(boot_data)-0.01, y=1.0, labels="expected value",
lwd=2, srt=90, pos=3)
set.seed(1121) # Reset random number generator
n_rows <- 1000
da_ta <- rnorm(n_rows)
quan_tile <- (-2)
pnorm(quan_tile)
quan_tile
integrate(dnorm, lower=-Inf, upper=quan_tile)
sum(da_ta < quan_tile)/n_rows
lamb_da <- (-1.5)  # Tilt parameter
data_tilt <- da_ta + lamb_da  # Tilt the random numbers
sum(da_ta < quan_tile)/n_rows
sum(data_tilt < quan_tile)/n_rows
weight_s <- exp(-lamb_da*data_tilt + lamb_da^2/2)
sum((data_tilt < quan_tile)*weight_s)/n_rows
pnorm(quan_tile)
n_boot <- 1000
boot_data <- sapply(1:n_boot, function(x) {
da_ta <- rnorm(n_rows)
na_ive <- sum(da_ta < quan_tile)/n_rows
da_ta <- (da_ta + lamb_da)
weight_s <- exp(-lamb_da*da_ta + lamb_da^2/2)
im_port <- sum((da_ta < quan_tile)*weight_s)/n_rows
c(naive_mc=na_ive, importance=im_port)
}) # end sapply
apply(boot_data, MARGIN=1,
function(x) c(mean=mean(x), sd=sd(x)))
0.00459/0.00134
conf_level <- 0.02
qnorm(conf_level)  # Exact value
da_ta <- sort(da_ta)
cut_off <- n_rows*conf_level
da_ta[cut_off]  # Naive Monte Carlo value
da_ta[cut_off]
cum_prob <- cumsum(weight_s)/n_rows
data_tilt[findInterval(conf_level, cum_prob)]
n_boot <- 1000
boot_data <- sapply(1:n_boot, function(x) {
da_ta <- sort(rnorm(n_rows))
na_ive <- da_ta[cut_off]
data_tilt <- da_ta + lamb_da
weight_s <- exp(-lamb_da*data_tilt + lamb_da^2/2)
cum_prob <- cumsum(weight_s)/n_rows
im_port <- data_tilt[findInterval(conf_level, cum_prob)]
c(naive_mc=na_ive, importance=im_port)
}) # end sapply
apply(boot_data, MARGIN=1,
function(x) c(mean=mean(x), sd=sd(x)))
0.0908/0.0248
va_r <- da_ta[cut_off]
va_r
sum((da_ta < va_r)*da_ta)
sum((da_ta < va_r))
sum((da_ta < va_r)*da_ta)/sum((da_ta < va_r))
va_r <- data_tilt[findInterval(conf_level, cum_prob)]
va_r
sum((data_tilt < va_r)*data_tilt*weight_s)/sum((data_tilt < va_r)*weight_s)
integrate(function(x) x*dnorm(x), low=-Inf, up=va_r)$value/pnorm(va_r)
n_boot <- 1000
boot_data <- sapply(1:n_boot, function(x) {
da_ta <- sort(rnorm(n_rows))
va_r <- da_ta[cut_off]
na_ive <- sum((da_ta < va_r)*da_ta)/sum((da_ta < va_r))
data_tilt <- da_ta + lamb_da
weight_s <- exp(-lamb_da*data_tilt + lamb_da^2/2)
cum_prob <- cumsum(weight_s)/n_rows
va_r <- data_tilt[findInterval(conf_level, cum_prob)]
im_port <- sum((data_tilt < va_r)*data_tilt*weight_s)/sum((data_tilt < va_r)*weight_s)
c(naive_mc=na_ive, importance=im_port)
}) # end sapply
apply(boot_data, MARGIN=1,
function(x) c(mean=mean(x), sd=sd(x)))
0.113/0.0201
load("/Users/jerzy/Develop/lecture_slides/data/sp500.RData")
price_s <- eapply(sp500_env, quantmod::Cl)
price_s <- rutils::do_call(cbind, price_s)
price_s <- zoo::na.locf(price_s, na.rm=FALSE)
colnames(price_s[, 1:4])
colnames(price_s) <- rutils::get_name(colnames(price_s))
da_ta <- rowSums(is.na(price_s))
da_ta <- xts::xts(da_ta, order.by=index(price_s))
dygraphs::dygraph(da_ta, main="Number of S&P 500 Constituents Without Prices") %>%
dyOptions(colors="blue", strokeWidth=2) %>%
dyAxis("y", valueRange=c(0, 300))
n_cols <- NCOL(price_s)
in_dex <- xts(rowSums(price_s)/n_cols, index(price_s))
colnames(in_dex) <- "index"
# Combine index with VTI
da_ta <- cbind(in_dex[index(etf_env$VTI)], etf_env$VTI[, 4])
col_names <- c("index", "VTI")
colnames(da_ta) <- col_names
# Plot index with VTI
dygraphs::dygraph(da_ta,
main="S&P 500 Price-weighted Index and VTI") %>%
dyAxis("y", label=col_names[1], independentTicks=TRUE) %>%
dyAxis("y2", label=col_names[2], independentTicks=TRUE) %>%
dySeries(name=col_names[1], axis="y", col="red") %>%
dySeries(name=col_names[2], axis="y2", col="blue")
tail(da_ta)
head(da_ta)
da_ta <- na.omi(da_ta)
da_ta <- na.omit(da_ta)
dim(da_ta)
args(na.omit)
args(na.locf)
help(na.locf)
price_s <- zoo::na.locf(price_s, fromLast=TRUE)
sum(is.na(price_s))
n_cols <- NCOL(price_s)
in_dex <- xts(rowSums(price_s)/n_cols, index(price_s))
colnames(in_dex) <- "index"
da_ta <- cbind(in_dex[index(etf_env$VTI)], etf_env$VTI[, 4])
col_names <- c("index", "VTI")
colnames(da_ta) <- col_names
# Plot index with VTI
dygraphs::dygraph(da_ta,
main="S&P 500 Price-weighted Index and VTI") %>%
dyAxis("y", label=col_names[1], independentTicks=TRUE) %>%
dyAxis("y2", label=col_names[2], independentTicks=TRUE) %>%
dySeries(name=col_names[1], axis="y", col="red") %>%
dySeries(name=col_names[2], axis="y2", col="blue")
ls(rutils::etf_env)
